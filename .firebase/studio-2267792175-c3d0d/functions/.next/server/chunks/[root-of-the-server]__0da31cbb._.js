module.exports=[58357,(e,t,s)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a={},c={Analytics:()=>d};for(var l in c)n(a,l,{get:c[l],enumerable:!0});t.exports=((e,t,s,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of r(t))o.call(e,c)||c===s||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),a);var h=`
local key = KEYS[1]
local field = ARGV[1]

local data = redis.call("ZRANGE", key, 0, -1, "WITHSCORES")
local count = {}

for i = 1, #data, 2 do
  local json_str = data[i]
  local score = tonumber(data[i + 1])
  local obj = cjson.decode(json_str)

  local fieldValue = obj[field]

  if count[fieldValue] == nil then
    count[fieldValue] = score
  else
    count[fieldValue] = count[fieldValue] + score
  end
end

local result = {}
for k, v in pairs(count) do
  table.insert(result, {k, v})
end

return result
`,u=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1]) -- First timestamp to check
local increment = tonumber(ARGV[2])       -- Increment between each timestamp
local num_timestamps = tonumber(ARGV[3])  -- Number of timestampts to check (24 for a day and 24 * 7 for a week)
local num_elements = tonumber(ARGV[4])    -- Number of elements to fetch in each category
local check_at_most = tonumber(ARGV[5])   -- Number of elements to check at most.

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

-- select num_elements many items
local true_group = {}
local false_group = {}
local denied_group = {}
local true_count = 0
local false_count = 0
local denied_count = 0
local i = #result - 1

-- index to stop at after going through "checkAtMost" many items:
local cutoff_index = #result - 2 * check_at_most

-- iterate over the results
while (true_count + false_count + denied_count) < (num_elements * 3) and 1 <= i and i >= cutoff_index do
  local score = tonumber(result[i + 1])
  if score > 0 then
    local element = result[i]
    if string.find(element, "success\\":true") and true_count < num_elements then
      table.insert(true_group, {score, element})
      true_count = true_count + 1
    elseif string.find(element, "success\\":false") and false_count < num_elements then
      table.insert(false_group, {score, element})
      false_count = false_count + 1
    elseif string.find(element, "success\\":\\"denied") and denied_count < num_elements then
      table.insert(denied_group, {score, element})
      denied_count = denied_count + 1
    end
  end
  i = i - 2
end

return {true_group, false_group, denied_group}
`,p=`
local prefix = KEYS[1]
local first_timestamp = tonumber(ARGV[1])
local increment = tonumber(ARGV[2])
local num_timestamps = tonumber(ARGV[3])

local keys = {}
for i = 1, num_timestamps do
  local timestamp = first_timestamp - (i - 1) * increment
  table.insert(keys, prefix .. ":" .. timestamp)
end

-- get the union of the groups
local zunion_params = {"ZUNION", num_timestamps, unpack(keys)}
table.insert(zunion_params, "WITHSCORES")
local result = redis.call(unpack(zunion_params))

return result
`,d=class{redis;prefix;bucketSize;constructor(e){this.redis=e.redis,this.prefix=e.prefix??"@upstash/analytics",this.bucketSize=this.parseWindow(e.window)}validateTableName(e){if(!/^[a-zA-Z0-9_-]+$/.test(e))throw Error(`Invalid table name: ${e}. Table names can only contain letters, numbers, dashes and underscores.`)}parseWindow(e){if("number"==typeof e){if(e<=0)throw Error(`Invalid window: ${e}`);return e}let t=/^(\d+)([smhd])$/;if(!t.test(e))throw Error(`Invalid window: ${e}`);let[,s,n]=e.match(t),i=parseInt(s);switch(n){case"s":return 1e3*i;case"m":return 1e3*i*60;case"h":return 1e3*i*3600;case"d":return 1e3*i*86400;default:throw Error(`Invalid window unit: ${n}`)}}getBucket(e){return Math.floor((e??Date.now())/this.bucketSize)*this.bucketSize}async ingest(e,...t){this.validateTableName(e),await Promise.all(t.map(async t=>{let s=this.getBucket(t.time),n=[this.prefix,e,s].join(":");await this.redis.zincrby(n,1,JSON.stringify({...t,time:void 0}))}))}formatBucketAggregate(e,t,s){let n={};return e.forEach(([e,s])=>{"success"==t&&(e=1===e?"true":null===e?"false":e),n[t]=n[t]||{},n[t][(e??"null").toString()]=s}),{time:s,...n}}async aggregateBucket(e,t,s){this.validateTableName(e);let n=this.getBucket(s),i=[this.prefix,e,n].join(":"),r=await this.redis.eval(h,[i],[t]);return this.formatBucketAggregate(r,t,n)}async aggregateBuckets(e,t,s,n){this.validateTableName(e);let i=this.getBucket(n),r=[];for(let n=0;n<s;n+=1)r.push(this.aggregateBucket(e,t,i)),i-=this.bucketSize;return Promise.all(r)}async aggregateBucketsWithPipeline(e,t,s,n,i){this.validateTableName(e),i=i??48;let r=this.getBucket(n),o=[],a=this.redis.pipeline(),c=[];for(let n=1;n<=s;n+=1){let l=[this.prefix,e,r].join(":");a.eval(h,[l],[t]),o.push(r),r-=this.bucketSize,(n%i==0||n==s)&&(c.push(a.exec()),a=this.redis.pipeline())}return(await Promise.all(c)).flat().map((e,s)=>this.formatBucketAggregate(e,t,o[s]))}async getAllowedBlocked(e,t,s){this.validateTableName(e);let n=[this.prefix,e].join(":"),i=this.getBucket(s),r=await this.redis.eval(p,[n],[i,this.bucketSize,t]),o={};for(let e=0;e<r.length;e+=2){let t=r[e],s=t.identifier,n=+r[e+1];o[s]||(o[s]={success:0,blocked:0}),o[s][t.success?"success":"blocked"]=n}return o}async getMostAllowedBlocked(e,t,s,n,i){this.validateTableName(e);let r=[this.prefix,e].join(":"),o=this.getBucket(n),[a,c,l]=await this.redis.eval(u,[r],[o,this.bucketSize,t,s,i??5*s]);return{allowed:this.toDicts(a),ratelimited:this.toDicts(c),denied:this.toDicts(l)}}toDicts(e){let t=[];for(let s=0;s<e.length;s+=1){let n=+e[s][0],i=e[s][1];t.push({identifier:i.identifier,count:n})}return t}}},15411,(e,t,s)=>{"use strict";var n=Object.defineProperty,i=Object.getOwnPropertyDescriptor,r=Object.getOwnPropertyNames,o=Object.prototype.hasOwnProperty,a=(e,t)=>{for(var s in t)n(e,s,{get:t[s],enumerable:!0})},c={};a(c,{Analytics:()=>h,IpDenyList:()=>E,MultiRegionRatelimit:()=>I,Ratelimit:()=>N}),t.exports=((e,t,s,a)=>{if(t&&"object"==typeof t||"function"==typeof t)for(let c of r(t))o.call(e,c)||c===s||n(e,c,{get:()=>t[c],enumerable:!(a=i(t,c))||a.enumerable});return e})(n({},"__esModule",{value:!0}),c);var l=e.r(58357),h=class{analytics;table="events";constructor(e){this.analytics=new l.Analytics({redis:e.redis,window:"1h",prefix:e.prefix??"@upstash/ratelimit",retention:"90d"})}extractGeo(e){return void 0!==e.geo?e.geo:void 0!==e.cf?e.cf:{}}async record(e){await this.analytics.ingest(this.table,e)}async series(e,t){let s=Math.min((this.analytics.getBucket(Date.now())-this.analytics.getBucket(t))/36e5,256);return this.analytics.aggregateBucketsWithPipeline(this.table,e,s)}async getUsage(e=0){let t=Math.min((this.analytics.getBucket(Date.now())-this.analytics.getBucket(e))/36e5,256);return await this.analytics.getAllowedBlocked(this.table,t)}async getUsageOverTime(e,t){return await this.analytics.aggregateBucketsWithPipeline(this.table,t,e)}async getMostAllowedBlocked(e,t,s){return t=t??5,this.analytics.getMostAllowedBlocked(this.table,e,t,void 0,s)}},u=class{cache;constructor(e){this.cache=e}isBlocked(e){if(!this.cache.has(e))return{blocked:!1,reset:0};let t=this.cache.get(e);return t<Date.now()?(this.cache.delete(e),{blocked:!1,reset:0}):{blocked:!0,reset:t}}blockUntil(e,t){this.cache.set(e,t)}set(e,t){this.cache.set(e,t)}get(e){return this.cache.get(e)||null}incr(e,t=1){let s=this.cache.get(e)??0;return s+=t,this.cache.set(e,s),s}pop(e){this.cache.delete(e)}empty(){this.cache.clear()}size(){return this.cache.size}};function p(e){let t=e.match(/^(\d+)\s?(ms|s|m|h|d)$/);if(!t)throw Error(`Unable to parse window size: ${e}`);let s=Number.parseInt(t[1]);switch(t[2]){case"ms":return s;case"s":return 1e3*s;case"m":return 1e3*s*60;case"h":return 1e3*s*3600;case"d":return 1e3*s*86400;default:throw Error(`Unable to parse window size: ${e}`)}}var d=async(e,t,s,n)=>{try{return await e.redis.evalsha(t.hash,s,n)}catch(i){if(`${i}`.includes("NOSCRIPT"))return await e.redis.eval(t.script,s,n);throw i}},m={fixedWindow:{limit:{script:`
  local key           = KEYS[1]
  local window        = ARGV[1]
  local incrementBy   = ARGV[2] -- increment rate per request at a given value, default is 1

  local r = redis.call("INCRBY", key, incrementBy)
  if r == tonumber(incrementBy) then
  -- The first time this key is set, the value will be equal to incrementBy.
  -- So we only need the expire command once
  redis.call("PEXPIRE", key, window)
  end

  return r
`,hash:"b13943e359636db027ad280f1def143f02158c13"},getRemaining:{script:`
      local key = KEYS[1]
      local tokens = 0

      local value = redis.call('GET', key)
      if value then
          tokens = value
      end
      return tokens
    `,hash:"8c4c341934502aee132643ffbe58ead3450e5208"}},slidingWindow:{limit:{script:`
  local currentKey  = KEYS[1]           -- identifier including prefixes
  local previousKey = KEYS[2]           -- key of the previous bucket
  local tokens      = tonumber(ARGV[1]) -- tokens per window
  local now         = ARGV[2]           -- current timestamp in milliseconds
  local window      = ARGV[3]           -- interval in milliseconds
  local incrementBy = tonumber(ARGV[4]) -- increment rate per request at a given value, default is 1

  local requestsInCurrentWindow = redis.call("GET", currentKey)
  if requestsInCurrentWindow == false then
    requestsInCurrentWindow = 0
  end

  local requestsInPreviousWindow = redis.call("GET", previousKey)
  if requestsInPreviousWindow == false then
    requestsInPreviousWindow = 0
  end
  local percentageInCurrent = ( now % window ) / window
  -- weighted requests to consider from the previous window
  requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)

  -- Only check limit if not refunding (negative rate)
  if incrementBy > 0 and requestsInPreviousWindow + requestsInCurrentWindow >= tokens then
    return -1
  end

  local newValue = redis.call("INCRBY", currentKey, incrementBy)
  if newValue == incrementBy then
    -- The first time this key is set, the value will be equal to incrementBy.
    -- So we only need the expire command once
    redis.call("PEXPIRE", currentKey, window * 2 + 1000) -- Enough time to overlap with a new window + 1 second
  end
  return tokens - ( newValue + requestsInPreviousWindow )
`,hash:"9b7842963bd73721f1a3011650c23c0010848ee3"},getRemaining:{script:`
  local currentKey  = KEYS[1]           -- identifier including prefixes
  local previousKey = KEYS[2]           -- key of the previous bucket
  local now         = ARGV[1]           -- current timestamp in milliseconds
  local window      = ARGV[2]           -- interval in milliseconds

  local requestsInCurrentWindow = redis.call("GET", currentKey)
  if requestsInCurrentWindow == false then
    requestsInCurrentWindow = 0
  end

  local requestsInPreviousWindow = redis.call("GET", previousKey)
  if requestsInPreviousWindow == false then
    requestsInPreviousWindow = 0
  end

  local percentageInCurrent = ( now % window ) / window
  -- weighted requests to consider from the previous window
  requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)

  return requestsInPreviousWindow + requestsInCurrentWindow
`,hash:"65a73ac5a05bf9712903bc304b77268980c1c417"}},tokenBucket:{limit:{script:`
  local key         = KEYS[1]           -- identifier including prefixes
  local maxTokens   = tonumber(ARGV[1]) -- maximum number of tokens
  local interval    = tonumber(ARGV[2]) -- size of the window in milliseconds
  local refillRate  = tonumber(ARGV[3]) -- how many tokens are refilled after each interval
  local now         = tonumber(ARGV[4]) -- current timestamp in milliseconds
  local incrementBy = tonumber(ARGV[5]) -- how many tokens to consume, default is 1
        
  local bucket = redis.call("HMGET", key, "refilledAt", "tokens")
        
  local refilledAt
  local tokens

  if bucket[1] == false then
    refilledAt = now
    tokens = maxTokens
  else
    refilledAt = tonumber(bucket[1])
    tokens = tonumber(bucket[2])
  end
        
  if now >= refilledAt + interval then
    local numRefills = math.floor((now - refilledAt) / interval)
    tokens = math.min(maxTokens, tokens + numRefills * refillRate)

    refilledAt = refilledAt + numRefills * interval
  end

  -- Only reject if tokens are 0 and we're consuming (not refunding)
  if tokens == 0 and incrementBy > 0 then
    return {-1, refilledAt + interval}
  end

  local remaining = tokens - incrementBy
  local expireAt = math.ceil(((maxTokens - remaining) / refillRate)) * interval
        
  redis.call("HSET", key, "refilledAt", refilledAt, "tokens", remaining)

  if (expireAt > 0) then
    redis.call("PEXPIRE", key, expireAt)
  end
  return {remaining, refilledAt + interval}
`,hash:"d1f857ebbdaeca90ccd2cd4eada61d7c8e5db1ca"},getRemaining:{script:`
  local key         = KEYS[1]
  local maxTokens   = tonumber(ARGV[1])
        
  local bucket = redis.call("HMGET", key, "refilledAt", "tokens")

  if bucket[1] == false then
    return {maxTokens, -1}
  end
        
  return {tonumber(bucket[2]), tonumber(bucket[1])}
`,hash:"a15be2bb1db2a15f7c82db06146f9d08983900d0"}},cachedFixedWindow:{limit:{script:`
  local key     = KEYS[1]
  local window  = ARGV[1]
  local incrementBy   = ARGV[2] -- increment rate per request at a given value, default is 1

  local r = redis.call("INCRBY", key, incrementBy)
  if r == incrementBy then
  -- The first time this key is set, the value will be equal to incrementBy.
  -- So we only need the expire command once
  redis.call("PEXPIRE", key, window)
  end
      
  return r
`,hash:"c26b12703dd137939b9a69a3a9b18e906a2d940f"},getRemaining:{script:`
  local key = KEYS[1]
  local tokens = 0

  local value = redis.call('GET', key)
  if value then
      tokens = value
  end
  return tokens
`,hash:"8e8f222ccae68b595ee6e3f3bf2199629a62b91a"}}},w={fixedWindow:{limit:{script:`
	local key           = KEYS[1]
	local id            = ARGV[1]
	local window        = ARGV[2]
	local incrementBy   = tonumber(ARGV[3])

	redis.call("HSET", key, id, incrementBy)
	local fields = redis.call("HGETALL", key)
	if #fields == 2 and tonumber(fields[2])==incrementBy then
	-- The first time this key is set, and the value will be equal to incrementBy.
	-- So we only need the expire command once
	  redis.call("PEXPIRE", key, window)
	end

	return fields
`,hash:"a8c14f3835aa87bd70e5e2116081b81664abcf5c"},getRemaining:{script:`
      local key = KEYS[1]
      local tokens = 0

      local fields = redis.call("HGETALL", key)

      return fields
    `,hash:"8ab8322d0ed5fe5ac8eb08f0c2e4557f1b4816fd"}},slidingWindow:{limit:{script:`
	local currentKey    = KEYS[1]           -- identifier including prefixes
	local previousKey   = KEYS[2]           -- key of the previous bucket
	local tokens        = tonumber(ARGV[1]) -- tokens per window
	local now           = ARGV[2]           -- current timestamp in milliseconds
	local window        = ARGV[3]           -- interval in milliseconds
	local requestId     = ARGV[4]           -- uuid for this request
	local incrementBy   = tonumber(ARGV[5]) -- custom rate, default is  1

	local currentFields = redis.call("HGETALL", currentKey)
	local requestsInCurrentWindow = 0
	for i = 2, #currentFields, 2 do
	requestsInCurrentWindow = requestsInCurrentWindow + tonumber(currentFields[i])
	end

	local previousFields = redis.call("HGETALL", previousKey)
	local requestsInPreviousWindow = 0
	for i = 2, #previousFields, 2 do
	requestsInPreviousWindow = requestsInPreviousWindow + tonumber(previousFields[i])
	end

	local percentageInCurrent = ( now % window) / window

	-- Only check limit if not refunding (negative rate)
	if incrementBy > 0 and requestsInPreviousWindow * (1 - percentageInCurrent ) + requestsInCurrentWindow + incrementBy > tokens then
	  return {currentFields, previousFields, false}
	end

	redis.call("HSET", currentKey, requestId, incrementBy)

	if requestsInCurrentWindow == 0 then 
	  -- The first time this key is set, the value will be equal to incrementBy.
	  -- So we only need the expire command once
	  redis.call("PEXPIRE", currentKey, window * 2 + 1000) -- Enough time to overlap with a new window + 1 second
	end
	return {currentFields, previousFields, true}
`,hash:"1e7ca8dcd2d600a6d0124a67a57ea225ed62921b"},getRemaining:{script:`
	local currentKey    = KEYS[1]           -- identifier including prefixes
	local previousKey   = KEYS[2]           -- key of the previous bucket
	local now         	= ARGV[1]           -- current timestamp in milliseconds
  	local window      	= ARGV[2]           -- interval in milliseconds

	local currentFields = redis.call("HGETALL", currentKey)
	local requestsInCurrentWindow = 0
	for i = 2, #currentFields, 2 do
	requestsInCurrentWindow = requestsInCurrentWindow + tonumber(currentFields[i])
	end

	local previousFields = redis.call("HGETALL", previousKey)
	local requestsInPreviousWindow = 0
	for i = 2, #previousFields, 2 do
	requestsInPreviousWindow = requestsInPreviousWindow + tonumber(previousFields[i])
	end

	local percentageInCurrent = ( now % window) / window
  	requestsInPreviousWindow = math.floor(( 1 - percentageInCurrent ) * requestsInPreviousWindow)
	
	return requestsInCurrentWindow + requestsInPreviousWindow
`,hash:"558c9306b7ec54abb50747fe0b17e5d44bd24868"}}},f={script:`
      local pattern = KEYS[1]

      -- Initialize cursor to start from 0
      local cursor = "0"

      repeat
          -- Scan for keys matching the pattern
          local scan_result = redis.call('SCAN', cursor, 'MATCH', pattern)

          -- Extract cursor for the next iteration
          cursor = scan_result[1]

          -- Extract keys from the scan result
          local keys = scan_result[2]

          for i=1, #keys do
          redis.call('DEL', keys[i])
          end

      -- Continue scanning until cursor is 0 (end of keyspace)
      until cursor == "0"
    `,hash:"54bd274ddc59fb3be0f42deee2f64322a10e2b50"},g="denyList",x="ipDenyList",y="ipDenyListStatus",b=`
  -- Checks if values provideed in ARGV are present in the deny lists.
  -- This is done using the allDenyListsKey below.

  -- Additionally, checks the status of the ip deny list using the
  -- ipDenyListStatusKey below. Here are the possible states of the
  -- ipDenyListStatusKey key:
  -- * status == -1: set to "disabled" with no TTL
  -- * status == -2: not set, meaning that is was set before but expired
  -- * status  >  0: set to "valid", with a TTL
  --
  -- In the case of status == -2, we set the status to "pending" with
  -- 30 second ttl. During this time, the process which got status == -2
  -- will update the ip deny list.

  local allDenyListsKey     = KEYS[1]
  local ipDenyListStatusKey = KEYS[2]

  local results = redis.call('SMISMEMBER', allDenyListsKey, unpack(ARGV))
  local status  = redis.call('TTL', ipDenyListStatusKey)
  if status == -2 then
    redis.call('SETEX', ipDenyListStatusKey, 30, "pending")
  end

  return { results, status }
`,E={};a(E,{ThresholdError:()=>O,disableIpDenyList:()=>A,updateIpDenyList:()=>v});var O=class extends Error{constructor(e){super(`Allowed threshold values are from 1 to 8, 1 and 8 included. Received: ${e}`),this.name="ThresholdError"}},R=async e=>{if("number"!=typeof e||e<1||e>8)throw new O(e);try{let t=await fetch(`https://raw.githubusercontent.com/stamparm/ipsum/master/levels/${e}.txt`);if(!t.ok)throw Error(`Error fetching data: ${t.statusText}`);return(await t.text()).split("\n").filter(e=>e.length>0)}catch(e){throw Error(`Failed to fetch ip deny list: ${e}`)}},v=async(e,t,s,n)=>{var i;let r=await R(s),o=[t,g,"all"].join(":"),a=[t,g,x].join(":"),c=[t,y].join(":"),l=e.multi();return l.sdiffstore(o,o,a),l.del(a),l.sadd(a,r.at(0),...r.slice(1)),l.sdiffstore(a,a,o),l.sunionstore(o,o,a),l.set(c,"valid",{px:n??864e5-((i||Date.now())-72e5)%864e5}),await l.exec()},A=async(e,t)=>{let s=[t,g,"all"].join(":"),n=[t,g,x].join(":"),i=[t,y].join(":"),r=e.multi();return r.sdiffstore(s,s,n),r.del(n),r.set(i,"disabled"),await r.exec()},T=new u(new Map),S=async(e,t,s)=>{let n,[i,r]=await e.eval(b,[[t,g,"all"].join(":"),[t,y].join(":")],s);return i.map((e,t)=>{if(e){var i;i=s[t],T.size()>1e3&&T.empty(),T.blockUntil(i,Date.now()+6e4),n=s[t]}}),{deniedValue:n,invalidIpDenyList:-2===r}},C=class{limiter;ctx;prefix;timeout;primaryRedis;analytics;enableProtection;denyListThreshold;constructor(e){this.ctx=e.ctx,this.limiter=e.limiter,this.timeout=e.timeout??5e3,this.prefix=e.prefix??"@upstash/ratelimit",this.enableProtection=e.enableProtection??!1,this.denyListThreshold=e.denyListThreshold??6,this.primaryRedis="redis"in this.ctx?this.ctx.redis:this.ctx.regionContexts[0].redis,this.analytics=e.analytics?new h({redis:this.primaryRedis,prefix:this.prefix}):void 0,e.ephemeralCache instanceof Map?this.ctx.cache=new u(e.ephemeralCache):void 0===e.ephemeralCache&&(this.ctx.cache=new u(new Map))}limit=async(e,t)=>{let s=null;try{let n=this.getRatelimitResponse(e,t),{responseArray:i,newTimeoutId:r}=this.applyTimeout(n);s=r;let o=await Promise.race(i);return this.submitAnalytics(o,e,t)}finally{s&&clearTimeout(s)}};blockUntilReady=async(e,t)=>{let s;if(t<=0)throw Error("timeout must be positive");let n=Date.now()+t;for(;!(s=await this.limit(e)).success;){if(0===s.reset)throw Error("This should not happen");let e=Math.min(s.reset,n)-Date.now();if(await new Promise(t=>setTimeout(t,e)),Date.now()>n)break}return s};resetUsedTokens=async e=>{let t=[this.prefix,e].join(":");await this.limiter().resetTokens(this.ctx,t)};getRemaining=async e=>{let t=[this.prefix,e].join(":");return await this.limiter().getRemaining(this.ctx,t)};getRatelimitResponse=async(e,t)=>{let s=this.getKey(e),n=this.getDefinedMembers(e,t),i=n.find(e=>T.isBlocked(e).blocked),r=i?[{success:!1,limit:0,remaining:0,reset:0,pending:Promise.resolve(),reason:"denyList",deniedValue:i},{deniedValue:i,invalidIpDenyList:!1}]:await Promise.all([this.limiter().limit(this.ctx,s,t?.rate),this.enableProtection?S(this.primaryRedis,this.prefix,n):{deniedValue:void 0,invalidIpDenyList:!1}]);return((e,t,[s,n],i)=>{if(n.deniedValue&&(s.success=!1,s.remaining=0,s.reason="denyList",s.deniedValue=n.deniedValue),n.invalidIpDenyList){let n=v(e,t,i);s.pending=Promise.all([s.pending,n])}return s})(this.primaryRedis,this.prefix,r,this.denyListThreshold)};applyTimeout=e=>{let t=null,s=[e];if(this.timeout>0){let e=new Promise(e=>{t=setTimeout(()=>{e({success:!0,limit:0,remaining:0,reset:0,pending:Promise.resolve(),reason:"timeout"})},this.timeout)});s.push(e)}return{responseArray:s,newTimeoutId:t}};submitAnalytics=(e,t,s)=>{if(this.analytics)try{let n=s?this.analytics.extractGeo(s):void 0,i=this.analytics.record({identifier:"denyList"===e.reason?e.deniedValue:t,time:Date.now(),success:"denyList"===e.reason?"denied":e.success,...n}).catch(e=>{let t="Failed to record analytics";`${e}`.includes("WRONGTYPE")&&(t=`
    Failed to record analytics. See the information below:

    This can occur when you uprade to Ratelimit version 1.1.2
    or later from an earlier version.

    This occurs simply because the way we store analytics data
    has changed. To avoid getting this error, disable analytics
    for *an hour*, then simply enable it back.

    `),console.warn(t,e)});e.pending=Promise.all([e.pending,i])}catch(e){console.warn("Failed to record analytics",e)}return e};getKey=e=>[this.prefix,e].join(":");getDefinedMembers=(e,t)=>[e,t?.ip,t?.userAgent,t?.country].filter(Boolean)};function k(){let e="",t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",s=t.length;for(let n=0;n<16;n++)e+=t.charAt(Math.floor(Math.random()*s));return e}var I=class extends C{constructor(e){super({prefix:e.prefix,limiter:e.limiter,timeout:e.timeout,analytics:e.analytics,ctx:{regionContexts:e.redis.map(e=>({redis:e})),cache:e.ephemeralCache?new u(e.ephemeralCache):void 0}})}static fixedWindow(e,t){let s=p(t);return()=>({async limit(t,n,i){let r=k(),o=Math.floor(Date.now()/s),a=[n,o].join(":"),c=i??1;if(t.cache&&c>0){let{blocked:s,reset:i}=t.cache.isBlocked(n);if(s)return{success:!1,limit:e,remaining:0,reset:i,pending:Promise.resolve(),reason:"cacheBlock"}}let l=t.regionContexts.map(e=>({redis:e.redis,request:d(e,w.fixedWindow.limit,[a],[r,s,c])})),h=e-(await Promise.any(l.map(e=>e.request))).reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0);async function u(){let t=[...new Set((await Promise.all(l.map(e=>e.request))).flat().reduce((e,t,s)=>(s%2==0&&e.push(t),e),[])).values()];for(let s of l){let n=(await s.request).reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0),i=(await s.request).reduce((e,t,s)=>(s%2==0&&e.push(t),e),[]);if(n>=e)continue;let r=t.filter(e=>!i.includes(e));if(0!==r.length)for(let e of r)await s.redis.hset(a,{[e]:c})}}let p=h>=0,m=(o+1)*s;return t.cache&&(p?c<0&&t.cache.pop(n):t.cache.blockUntil(n,m)),{success:p,limit:e,remaining:h,reset:m,pending:u()}},async getRemaining(t,n){let i=Math.floor(Date.now()/s),r=[n,i].join(":"),o=t.regionContexts.map(e=>({redis:e.redis,request:d(e,w.fixedWindow.getRemaining,[r],[null])}));return{remaining:Math.max(0,e-(await Promise.any(o.map(e=>e.request))).reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0)),reset:(i+1)*s}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await Promise.all(e.regionContexts.map(e=>{d(e,f,[s],[null])}))}})}static slidingWindow(e,t){let s=p(t),n=p(t);return()=>({async limit(t,i,r){let o=k(),a=Date.now(),c=Math.floor(a/s),l=[i,c].join(":"),h=[i,c-1].join(":"),u=r??1;if(t.cache&&u>0){let{blocked:s,reset:n}=t.cache.isBlocked(i);if(s)return{success:!1,limit:e,remaining:0,reset:n,pending:Promise.resolve(),reason:"cacheBlock"}}let p=t.regionContexts.map(t=>({redis:t.redis,request:d(t,w.slidingWindow.limit,[l,h],[e,a,n,o,u])})),m=a%n/n,[f,g,x]=await Promise.any(p.map(e=>e.request));x&&f.push(o,u.toString());let y=e-(Math.ceil(g.reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0)*(1-m))+f.reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0));async function b(){let t=[...new Set((await Promise.all(p.map(e=>e.request))).flatMap(([e])=>e).reduce((e,t,s)=>(s%2==0&&e.push(t),e),[])).values()];for(let s of p){let[n,i,r]=await s.request,o=n.reduce((e,t,s)=>(s%2==0&&e.push(t),e),[]);if(n.reduce((e,t,s)=>{let n=0;return s%2&&(n=Number.parseInt(t)),e+n},0)>=e)continue;let a=t.filter(e=>!o.includes(e));if(0!==a.length)for(let e of a)await s.redis.hset(l,{[e]:u})}}let E=(c+1)*n;return t.cache&&(x?u<0&&t.cache.pop(i):t.cache.blockUntil(i,E)),{success:!!x,limit:e,remaining:Math.max(0,y),reset:E,pending:b()}},async getRemaining(t,n){let i=Date.now(),r=Math.floor(i/s),o=[n,r].join(":"),a=[n,r-1].join(":"),c=t.regionContexts.map(e=>({redis:e.redis,request:d(e,w.slidingWindow.getRemaining,[o,a],[i,s])}));return{remaining:Math.max(0,e-await Promise.any(c.map(e=>e.request))),reset:(r+1)*s}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await Promise.all(e.regionContexts.map(e=>{d(e,f,[s],[null])}))}})}},N=class extends C{constructor(e){super({prefix:e.prefix,limiter:e.limiter,timeout:e.timeout,analytics:e.analytics,ctx:{redis:e.redis},ephemeralCache:e.ephemeralCache,enableProtection:e.enableProtection,denyListThreshold:e.denyListThreshold})}static fixedWindow(e,t){let s=p(t);return()=>({async limit(t,n,i){let r=Math.floor(Date.now()/s),o=[n,r].join(":"),a=i??1;if(t.cache&&a>0){let{blocked:s,reset:i}=t.cache.isBlocked(n);if(s)return{success:!1,limit:e,remaining:0,reset:i,pending:Promise.resolve(),reason:"cacheBlock"}}let c=await d(t,m.fixedWindow.limit,[o],[s,a]),l=c<=e,h=Math.max(0,e-c),u=(r+1)*s;return t.cache&&(l?a<0&&t.cache.pop(n):t.cache.blockUntil(n,u)),{success:l,limit:e,remaining:h,reset:u,pending:Promise.resolve()}},async getRemaining(t,n){let i=Math.floor(Date.now()/s),r=[n,i].join(":");return{remaining:Math.max(0,e-await d(t,m.fixedWindow.getRemaining,[r],[null])),reset:(i+1)*s}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await d(e,f,[s],[null])}})}static slidingWindow(e,t){let s=p(t);return()=>({async limit(t,n,i){let r=Date.now(),o=Math.floor(r/s),a=[n,o].join(":"),c=[n,o-1].join(":"),l=i??1;if(t.cache&&l>0){let{blocked:s,reset:i}=t.cache.isBlocked(n);if(s)return{success:!1,limit:e,remaining:0,reset:i,pending:Promise.resolve(),reason:"cacheBlock"}}let h=await d(t,m.slidingWindow.limit,[a,c],[e,r,s,l]),u=h>=0,p=(o+1)*s;return t.cache&&(u?l<0&&t.cache.pop(n):t.cache.blockUntil(n,p)),{success:u,limit:e,remaining:Math.max(0,h),reset:p,pending:Promise.resolve()}},async getRemaining(t,n){let i=Date.now(),r=Math.floor(i/s),o=[n,r].join(":"),a=[n,r-1].join(":");return{remaining:Math.max(0,e-await d(t,m.slidingWindow.getRemaining,[o,a],[i,s])),reset:(r+1)*s}},async resetTokens(e,t){let s=[t,"*"].join(":");e.cache&&e.cache.pop(t),await d(e,f,[s],[null])}})}static tokenBucket(e,t,s){let n=p(t);return()=>({async limit(t,i,r){let o=Date.now(),a=r??1;if(t.cache&&a>0){let{blocked:e,reset:n}=t.cache.isBlocked(i);if(e)return{success:!1,limit:s,remaining:0,reset:n,pending:Promise.resolve(),reason:"cacheBlock"}}let[c,l]=await d(t,m.tokenBucket.limit,[i],[s,n,e,o,a]),h=c>=0;return t.cache&&(h?a<0&&t.cache.pop(i):t.cache.blockUntil(i,l)),{success:h,limit:s,remaining:c,reset:l,pending:Promise.resolve()}},async getRemaining(e,t){let[i,r]=await d(e,m.tokenBucket.getRemaining,[t],[s]),o=Date.now()+n,a=r+n;return{remaining:i,reset:-1===r?o:a}},async resetTokens(e,t){e.cache&&e.cache.pop(t),await d(e,f,[t],[null])}})}static cachedFixedWindow(e,t){let s=p(t);return()=>({async limit(t,n,i){if(!t.cache)throw Error("This algorithm requires a cache");let r=Math.floor(Date.now()/s),o=[n,r].join(":"),a=(r+1)*s,c=i??1;if("number"==typeof t.cache.get(o)){let n=t.cache.incr(o,c),i=n<e,r=i?d(t,m.cachedFixedWindow.limit,[o],[s,c]):Promise.resolve();return{success:i,limit:e,remaining:e-n,reset:a,pending:r}}let l=await d(t,m.cachedFixedWindow.limit,[o],[s,c]);t.cache.set(o,l);let h=e-l;return{success:h>=0,limit:e,remaining:h,reset:a,pending:Promise.resolve()}},async getRemaining(t,n){if(!t.cache)throw Error("This algorithm requires a cache");let i=Math.floor(Date.now()/s),r=[n,i].join(":");return"number"==typeof t.cache.get(r)?{remaining:Math.max(0,e-(t.cache.get(r)??0)),reset:(i+1)*s}:{remaining:Math.max(0,e-await d(t,m.cachedFixedWindow.getRemaining,[r],[null])),reset:(i+1)*s}},async resetTokens(e,t){if(!e.cache)throw Error("This algorithm requires a cache");let n=[t,Math.floor(Date.now()/s)].join(":");e.cache.pop(n);let i=[t,"*"].join(":");await d(e,f,[i],[null])}})}}},66680,(e,t,s)=>{t.exports=e.x("node:crypto",()=>require("node:crypto"))},36751,e=>{"use strict";var t,s,n,i,r,o,a,c,l,h,u,p,d,m,w,f,g,x,y,b,E,O,R,v,A=e.i(47909),T=e.i(74017),S=e.i(96250),C=e.i(59756),k=e.i(61916),I=e.i(74677),N=e.i(69741),_=e.i(16795),P=e.i(87718),M=e.i(95169),L=e.i(47587),D=e.i(66012),U=e.i(70101),j=e.i(26937),G=e.i(10372),B=e.i(93695);e.i(52474);var z=e.i(220),q=e.i(89171);(t=d||(d={})).STRING="string",t.NUMBER="number",t.INTEGER="integer",t.BOOLEAN="boolean",t.ARRAY="array",t.OBJECT="object",(s=m||(m={})).LANGUAGE_UNSPECIFIED="language_unspecified",s.PYTHON="python",(n=w||(w={})).OUTCOME_UNSPECIFIED="outcome_unspecified",n.OUTCOME_OK="outcome_ok",n.OUTCOME_FAILED="outcome_failed",n.OUTCOME_DEADLINE_EXCEEDED="outcome_deadline_exceeded";let F=["user","model","function","system"];(i=f||(f={})).HARM_CATEGORY_UNSPECIFIED="HARM_CATEGORY_UNSPECIFIED",i.HARM_CATEGORY_HATE_SPEECH="HARM_CATEGORY_HATE_SPEECH",i.HARM_CATEGORY_SEXUALLY_EXPLICIT="HARM_CATEGORY_SEXUALLY_EXPLICIT",i.HARM_CATEGORY_HARASSMENT="HARM_CATEGORY_HARASSMENT",i.HARM_CATEGORY_DANGEROUS_CONTENT="HARM_CATEGORY_DANGEROUS_CONTENT",i.HARM_CATEGORY_CIVIC_INTEGRITY="HARM_CATEGORY_CIVIC_INTEGRITY",(r=g||(g={})).HARM_BLOCK_THRESHOLD_UNSPECIFIED="HARM_BLOCK_THRESHOLD_UNSPECIFIED",r.BLOCK_LOW_AND_ABOVE="BLOCK_LOW_AND_ABOVE",r.BLOCK_MEDIUM_AND_ABOVE="BLOCK_MEDIUM_AND_ABOVE",r.BLOCK_ONLY_HIGH="BLOCK_ONLY_HIGH",r.BLOCK_NONE="BLOCK_NONE",(o=x||(x={})).HARM_PROBABILITY_UNSPECIFIED="HARM_PROBABILITY_UNSPECIFIED",o.NEGLIGIBLE="NEGLIGIBLE",o.LOW="LOW",o.MEDIUM="MEDIUM",o.HIGH="HIGH",(a=y||(y={})).BLOCKED_REASON_UNSPECIFIED="BLOCKED_REASON_UNSPECIFIED",a.SAFETY="SAFETY",a.OTHER="OTHER",(c=b||(b={})).FINISH_REASON_UNSPECIFIED="FINISH_REASON_UNSPECIFIED",c.STOP="STOP",c.MAX_TOKENS="MAX_TOKENS",c.SAFETY="SAFETY",c.RECITATION="RECITATION",c.LANGUAGE="LANGUAGE",c.BLOCKLIST="BLOCKLIST",c.PROHIBITED_CONTENT="PROHIBITED_CONTENT",c.SPII="SPII",c.MALFORMED_FUNCTION_CALL="MALFORMED_FUNCTION_CALL",c.OTHER="OTHER",(l=E||(E={})).TASK_TYPE_UNSPECIFIED="TASK_TYPE_UNSPECIFIED",l.RETRIEVAL_QUERY="RETRIEVAL_QUERY",l.RETRIEVAL_DOCUMENT="RETRIEVAL_DOCUMENT",l.SEMANTIC_SIMILARITY="SEMANTIC_SIMILARITY",l.CLASSIFICATION="CLASSIFICATION",l.CLUSTERING="CLUSTERING",(h=O||(O={})).MODE_UNSPECIFIED="MODE_UNSPECIFIED",h.AUTO="AUTO",h.ANY="ANY",h.NONE="NONE",(u=R||(R={})).MODE_UNSPECIFIED="MODE_UNSPECIFIED",u.MODE_DYNAMIC="MODE_DYNAMIC";class K extends Error{constructor(e){super(`[GoogleGenerativeAI Error]: ${e}`)}}class H extends K{constructor(e,t){super(e),this.response=t}}class W extends K{constructor(e,t,s,n){super(e),this.status=t,this.statusText=s,this.errorDetails=n}}class Y extends K{}class $ extends K{}(p=v||(v={})).GENERATE_CONTENT="generateContent",p.STREAM_GENERATE_CONTENT="streamGenerateContent",p.COUNT_TOKENS="countTokens",p.EMBED_CONTENT="embedContent",p.BATCH_EMBED_CONTENTS="batchEmbedContents";class V{constructor(e,t,s,n,i){this.model=e,this.task=t,this.apiKey=s,this.stream=n,this.requestOptions=i}toString(){var e,t;let s=(null==(e=this.requestOptions)?void 0:e.apiVersion)||"v1beta",n=(null==(t=this.requestOptions)?void 0:t.baseUrl)||"https://generativelanguage.googleapis.com",i=`${n}/${s}/${this.model}:${this.task}`;return this.stream&&(i+="?alt=sse"),i}}async function J(e){var t,s;let n,i=new Headers;i.append("Content-Type","application/json"),i.append("x-goog-api-client",(s=e.requestOptions,n=[],(null==s?void 0:s.apiClient)&&n.push(s.apiClient),n.push("genai-js/0.24.1"),n.join(" "))),i.append("x-goog-api-key",e.apiKey);let r=null==(t=e.requestOptions)?void 0:t.customHeaders;if(r){if(!(r instanceof Headers))try{r=new Headers(r)}catch(e){throw new Y(`unable to convert customHeaders value ${JSON.stringify(r)} to Headers: ${e.message}`)}for(let[e,t]of r.entries()){if("x-goog-api-key"===e)throw new Y(`Cannot set reserved header name ${e}`);if("x-goog-api-client"===e)throw new Y(`Header name ${e} can only be set using the apiClient field`);i.append(e,t)}}return i}async function X(e,t,s,n,i,r){let o=new V(e,t,s,n,r);return{url:o.toString(),fetchOptions:Object.assign(Object.assign({},function(e){let t={};if((null==e?void 0:e.signal)!==void 0||(null==e?void 0:e.timeout)>=0){let s=new AbortController;(null==e?void 0:e.timeout)>=0&&setTimeout(()=>s.abort(),e.timeout),(null==e?void 0:e.signal)&&e.signal.addEventListener("abort",()=>{s.abort()}),t.signal=s.signal}return t}(r)),{method:"POST",headers:await J(o),body:i})}}async function Z(e,t,s,n,i,r={},o=fetch){let{url:a,fetchOptions:c}=await X(e,t,s,n,i,r);return Q(a,c,o)}async function Q(e,t,s=fetch){let n;try{n=await s(e,t)}catch(s){var i=s,r=e;let t=i;throw"AbortError"===t.name?(t=new $(`Request aborted when fetching ${r.toString()}: ${i.message}`)).stack=i.stack:i instanceof W||i instanceof Y||((t=new K(`Error fetching from ${r.toString()}: ${i.message}`)).stack=i.stack),t}return n.ok||await ee(n,e),n}async function ee(e,t){let s,n="";try{let t=await e.json();n=t.error.message,t.error.details&&(n+=` ${JSON.stringify(t.error.details)}`,s=t.error.details)}catch(e){}throw new W(`Error fetching from ${t.toString()}: [${e.status} ${e.statusText}] ${n}`,e.status,e.statusText,s)}function et(e){return e.text=()=>{if(e.candidates&&e.candidates.length>0){if(e.candidates.length>1&&console.warn(`This response had ${e.candidates.length} candidates. Returning text from the first candidate only. Access response.candidates directly to use the other candidates.`),ei(e.candidates[0]))throw new H(`${er(e)}`,e);return function(e){var t,s,n,i;let r=[];if(null==(s=null==(t=e.candidates)?void 0:t[0].content)?void 0:s.parts)for(let t of null==(i=null==(n=e.candidates)?void 0:n[0].content)?void 0:i.parts)t.text&&r.push(t.text),t.executableCode&&r.push("\n```"+t.executableCode.language+"\n"+t.executableCode.code+"\n```\n"),t.codeExecutionResult&&r.push("\n```\n"+t.codeExecutionResult.output+"\n```\n");return r.length>0?r.join(""):""}(e)}if(e.promptFeedback)throw new H(`Text not available. ${er(e)}`,e);return""},e.functionCall=()=>{if(e.candidates&&e.candidates.length>0){if(e.candidates.length>1&&console.warn(`This response had ${e.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`),ei(e.candidates[0]))throw new H(`${er(e)}`,e);return console.warn("response.functionCall() is deprecated. Use response.functionCalls() instead."),es(e)[0]}if(e.promptFeedback)throw new H(`Function call not available. ${er(e)}`,e)},e.functionCalls=()=>{if(e.candidates&&e.candidates.length>0){if(e.candidates.length>1&&console.warn(`This response had ${e.candidates.length} candidates. Returning function calls from the first candidate only. Access response.candidates directly to use the other candidates.`),ei(e.candidates[0]))throw new H(`${er(e)}`,e);return es(e)}if(e.promptFeedback)throw new H(`Function call not available. ${er(e)}`,e)},e}function es(e){var t,s,n,i;let r=[];if(null==(s=null==(t=e.candidates)?void 0:t[0].content)?void 0:s.parts)for(let t of null==(i=null==(n=e.candidates)?void 0:n[0].content)?void 0:i.parts)t.functionCall&&r.push(t.functionCall);return r.length>0?r:void 0}let en=[b.RECITATION,b.SAFETY,b.LANGUAGE];function ei(e){return!!e.finishReason&&en.includes(e.finishReason)}function er(e){var t,s,n;let i="";if((!e.candidates||0===e.candidates.length)&&e.promptFeedback)i+="Response was blocked",(null==(t=e.promptFeedback)?void 0:t.blockReason)&&(i+=` due to ${e.promptFeedback.blockReason}`),(null==(s=e.promptFeedback)?void 0:s.blockReasonMessage)&&(i+=`: ${e.promptFeedback.blockReasonMessage}`);else if(null==(n=e.candidates)?void 0:n[0]){let t=e.candidates[0];ei(t)&&(i+=`Candidate was blocked due to ${t.finishReason}`,t.finishMessage&&(i+=`: ${t.finishMessage}`))}return i}function eo(e){return this instanceof eo?(this.v=e,this):new eo(e)}"function"==typeof SuppressedError&&SuppressedError;let ea=/^data\: (.*)(?:\n\n|\r\r|\r\n\r\n)/;async function ec(e){let t=[],s=e.getReader();for(;;){let{done:e,value:n}=await s.read();if(e)return et(function(e){let t=e[e.length-1],s={promptFeedback:null==t?void 0:t.promptFeedback};for(let t of e){if(t.candidates){let e=0;for(let n of t.candidates)if(s.candidates||(s.candidates=[]),s.candidates[e]||(s.candidates[e]={index:e}),s.candidates[e].citationMetadata=n.citationMetadata,s.candidates[e].groundingMetadata=n.groundingMetadata,s.candidates[e].finishReason=n.finishReason,s.candidates[e].finishMessage=n.finishMessage,s.candidates[e].safetyRatings=n.safetyRatings,n.content&&n.content.parts){s.candidates[e].content||(s.candidates[e].content={role:n.content.role||"user",parts:[]});let t={};for(let i of n.content.parts)i.text&&(t.text=i.text),i.functionCall&&(t.functionCall=i.functionCall),i.executableCode&&(t.executableCode=i.executableCode),i.codeExecutionResult&&(t.codeExecutionResult=i.codeExecutionResult),0===Object.keys(t).length&&(t.text=""),s.candidates[e].content.parts.push(t)}e++}t.usageMetadata&&(s.usageMetadata=t.usageMetadata)}return s}(t));t.push(n)}}async function el(e,t,s,n){return function(e){let t,[s,n]=(t=e.body.pipeThrough(new TextDecoderStream("utf8",{fatal:!0})).getReader(),new ReadableStream({start(e){let s="";return function n(){return t.read().then(({value:t,done:i})=>{let r;if(i)return s.trim()?void e.error(new K("Failed to parse stream")):void e.close();let o=(s+=t).match(ea);for(;o;){try{r=JSON.parse(o[1])}catch(t){e.error(new K(`Error parsing JSON response: "${o[1]}"`));return}e.enqueue(r),o=(s=s.substring(o[0].length)).match(ea)}return n()}).catch(e=>{let t=e;throw t.stack=e.stack,t="AbortError"===t.name?new $("Request aborted when reading from the stream"):new K("Error reading from the stream")})}()}})).tee();return{stream:function(e){return function(e,t,s){if(!Symbol.asyncIterator)throw TypeError("Symbol.asyncIterator is not defined.");var n,i=s.apply(e,t||[]),r=[];return n={},o("next"),o("throw"),o("return"),n[Symbol.asyncIterator]=function(){return this},n;function o(e){i[e]&&(n[e]=function(t){return new Promise(function(s,n){r.push([e,t,s,n])>1||a(e,t)})})}function a(e,t){try{var s;(s=i[e](t)).value instanceof eo?Promise.resolve(s.value.v).then(c,l):h(r[0][2],s)}catch(e){h(r[0][3],e)}}function c(e){a("next",e)}function l(e){a("throw",e)}function h(e,t){e(t),r.shift(),r.length&&a(r[0][0],r[0][1])}}(this,arguments,function*(){let t=e.getReader();for(;;){let{value:e,done:s}=yield eo(t.read());if(s)break;yield yield eo(et(e))}})}(s),response:ec(n)}}(await Z(t,v.STREAM_GENERATE_CONTENT,e,!0,JSON.stringify(s),n))}async function eh(e,t,s,n){let i=await Z(t,v.GENERATE_CONTENT,e,!1,JSON.stringify(s),n);return{response:et(await i.json())}}function eu(e){if(null!=e){if("string"==typeof e)return{role:"system",parts:[{text:e}]};if(e.text)return{role:"system",parts:[e]};if(e.parts)if(!e.role)return{role:"system",parts:e.parts};else return e}}function ep(e){let t=[];if("string"==typeof e)t=[{text:e}];else for(let s of e)"string"==typeof s?t.push({text:s}):t.push(s);var s=t;let n={role:"user",parts:[]},i={role:"function",parts:[]},r=!1,o=!1;for(let e of s)"functionResponse"in e?(i.parts.push(e),o=!0):(n.parts.push(e),r=!0);if(r&&o)throw new K("Within a single message, FunctionResponse cannot be mixed with other type of part in the request for sending chat message.");if(!r&&!o)throw new K("No content is provided for sending chat message.");return r?n:i}function ed(e){let t;return t=e.contents?e:{contents:[ep(e)]},e.systemInstruction&&(t.systemInstruction=eu(e.systemInstruction)),t}let em=["text","inlineData","functionCall","functionResponse","executableCode","codeExecutionResult"],ew={user:["text","inlineData"],function:["functionResponse"],model:["text","functionCall","executableCode","codeExecutionResult"],system:["text"]};function ef(e){var t;if(void 0===e.candidates||0===e.candidates.length)return!1;let s=null==(t=e.candidates[0])?void 0:t.content;if(void 0===s||void 0===s.parts||0===s.parts.length)return!1;for(let e of s.parts)if(void 0===e||0===Object.keys(e).length||void 0!==e.text&&""===e.text)return!1;return!0}let eg="SILENT_ERROR";class ex{constructor(e,t,s,n={}){this.model=t,this.params=s,this._requestOptions=n,this._history=[],this._sendPromise=Promise.resolve(),this._apiKey=e,(null==s?void 0:s.history)&&(!function(e){let t=!1;for(let s of e){let{role:e,parts:n}=s;if(!t&&"user"!==e)throw new K(`First content should be with role 'user', got ${e}`);if(!F.includes(e))throw new K(`Each item should include role field. Got ${e} but valid roles are: ${JSON.stringify(F)}`);if(!Array.isArray(n))throw new K("Content should have 'parts' property with an array of Parts");if(0===n.length)throw new K("Each Content should have at least one part");let i={text:0,inlineData:0,functionCall:0,functionResponse:0,fileData:0,executableCode:0,codeExecutionResult:0};for(let e of n)for(let t of em)t in e&&(i[t]+=1);let r=ew[e];for(let t of em)if(!r.includes(t)&&i[t]>0)throw new K(`Content with role '${e}' can't contain '${t}' part`);t=!0}}(s.history),this._history=s.history)}async getHistory(){return await this._sendPromise,this._history}async sendMessage(e,t={}){var s,n,i,r,o,a;let c;await this._sendPromise;let l=ep(e),h={safetySettings:null==(s=this.params)?void 0:s.safetySettings,generationConfig:null==(n=this.params)?void 0:n.generationConfig,tools:null==(i=this.params)?void 0:i.tools,toolConfig:null==(r=this.params)?void 0:r.toolConfig,systemInstruction:null==(o=this.params)?void 0:o.systemInstruction,cachedContent:null==(a=this.params)?void 0:a.cachedContent,contents:[...this._history,l]},u=Object.assign(Object.assign({},this._requestOptions),t);return this._sendPromise=this._sendPromise.then(()=>eh(this._apiKey,this.model,h,u)).then(e=>{var t;if(ef(e.response)){this._history.push(l);let s=Object.assign({parts:[],role:"model"},null==(t=e.response.candidates)?void 0:t[0].content);this._history.push(s)}else{let t=er(e.response);t&&console.warn(`sendMessage() was unsuccessful. ${t}. Inspect response object for details.`)}c=e}).catch(e=>{throw this._sendPromise=Promise.resolve(),e}),await this._sendPromise,c}async sendMessageStream(e,t={}){var s,n,i,r,o,a;await this._sendPromise;let c=ep(e),l={safetySettings:null==(s=this.params)?void 0:s.safetySettings,generationConfig:null==(n=this.params)?void 0:n.generationConfig,tools:null==(i=this.params)?void 0:i.tools,toolConfig:null==(r=this.params)?void 0:r.toolConfig,systemInstruction:null==(o=this.params)?void 0:o.systemInstruction,cachedContent:null==(a=this.params)?void 0:a.cachedContent,contents:[...this._history,c]},h=Object.assign(Object.assign({},this._requestOptions),t),u=el(this._apiKey,this.model,l,h);return this._sendPromise=this._sendPromise.then(()=>u).catch(e=>{throw Error(eg)}).then(e=>e.response).then(e=>{if(ef(e)){this._history.push(c);let t=Object.assign({},e.candidates[0].content);t.role||(t.role="model"),this._history.push(t)}else{let t=er(e);t&&console.warn(`sendMessageStream() was unsuccessful. ${t}. Inspect response object for details.`)}}).catch(e=>{e.message!==eg&&console.error(e)}),u}}async function ey(e,t,s,n){return(await Z(t,v.COUNT_TOKENS,e,!1,JSON.stringify(s),n)).json()}async function eb(e,t,s,n){return(await Z(t,v.EMBED_CONTENT,e,!1,JSON.stringify(s),n)).json()}async function eE(e,t,s,n){let i=s.requests.map(e=>Object.assign(Object.assign({},e),{model:t}));return(await Z(t,v.BATCH_EMBED_CONTENTS,e,!1,JSON.stringify({requests:i}),n)).json()}class eO{constructor(e,t,s={}){this.apiKey=e,this._requestOptions=s,t.model.includes("/")?this.model=t.model:this.model=`models/${t.model}`,this.generationConfig=t.generationConfig||{},this.safetySettings=t.safetySettings||[],this.tools=t.tools,this.toolConfig=t.toolConfig,this.systemInstruction=eu(t.systemInstruction),this.cachedContent=t.cachedContent}async generateContent(e,t={}){var s;let n=ed(e),i=Object.assign(Object.assign({},this._requestOptions),t);return eh(this.apiKey,this.model,Object.assign({generationConfig:this.generationConfig,safetySettings:this.safetySettings,tools:this.tools,toolConfig:this.toolConfig,systemInstruction:this.systemInstruction,cachedContent:null==(s=this.cachedContent)?void 0:s.name},n),i)}async generateContentStream(e,t={}){var s;let n=ed(e),i=Object.assign(Object.assign({},this._requestOptions),t);return el(this.apiKey,this.model,Object.assign({generationConfig:this.generationConfig,safetySettings:this.safetySettings,tools:this.tools,toolConfig:this.toolConfig,systemInstruction:this.systemInstruction,cachedContent:null==(s=this.cachedContent)?void 0:s.name},n),i)}startChat(e){var t;return new ex(this.apiKey,this.model,Object.assign({generationConfig:this.generationConfig,safetySettings:this.safetySettings,tools:this.tools,toolConfig:this.toolConfig,systemInstruction:this.systemInstruction,cachedContent:null==(t=this.cachedContent)?void 0:t.name},e),this._requestOptions)}async countTokens(e,t={}){let s=function(e,t){var s;let n={model:null==t?void 0:t.model,generationConfig:null==t?void 0:t.generationConfig,safetySettings:null==t?void 0:t.safetySettings,tools:null==t?void 0:t.tools,toolConfig:null==t?void 0:t.toolConfig,systemInstruction:null==t?void 0:t.systemInstruction,cachedContent:null==(s=null==t?void 0:t.cachedContent)?void 0:s.name,contents:[]},i=null!=e.generateContentRequest;if(e.contents){if(i)throw new Y("CountTokensRequest must have one of contents or generateContentRequest, not both.");n.contents=e.contents}else if(i)n=Object.assign(Object.assign({},n),e.generateContentRequest);else{let t=ep(e);n.contents=[t]}return{generateContentRequest:n}}(e,{model:this.model,generationConfig:this.generationConfig,safetySettings:this.safetySettings,tools:this.tools,toolConfig:this.toolConfig,systemInstruction:this.systemInstruction,cachedContent:this.cachedContent}),n=Object.assign(Object.assign({},this._requestOptions),t);return ey(this.apiKey,this.model,s,n)}async embedContent(e,t={}){let s="string"==typeof e||Array.isArray(e)?{content:ep(e)}:e,n=Object.assign(Object.assign({},this._requestOptions),t);return eb(this.apiKey,this.model,s,n)}async batchEmbedContents(e,t={}){let s=Object.assign(Object.assign({},this._requestOptions),t);return eE(this.apiKey,this.model,e,s)}}var eR=e.i(15411),ev=e.i(66680);let eA=ev.default.webcrypto?.subtle||{};var eT=Object.defineProperty,eS={},eC={UpstashError:()=>eI,UpstashJSONParseError:()=>e_,UrlError:()=>eN};for(var ek in eC)eT(eS,ek,{get:eC[ek],enumerable:!0});var eI=class extends Error{constructor(e,t){super(e,t),this.name="UpstashError"}},eN=class extends Error{constructor(e){super(`Upstash Redis client was passed an invalid URL. You should pass a URL starting with https. Received: "${e}". `),this.name="UrlError"}},e_=class extends eI{constructor(e,t){super(`Unable to parse response body: ${e.length>200?e.slice(0,200)+"...":e}`,t),this.name="UpstashJSONParseError"}};function eP(e){try{return function e(t){let s=Array.isArray(t)?t.map(t=>{try{return e(t)}catch{return t}}):JSON.parse(t);return"number"==typeof s&&s.toString()!==t?t:s}(e)}catch{return e}}function eM(e){return[e[0],...eP(e.slice(1))]}function eL(e){let[t,s]=e,n=[];for(let e=0;e<s.length;e+=2)n.push({key:s[e],type:s[e+1]});return[t,n]}function eD(e){if("object"==typeof e&&null!==e&&!Array.isArray(e))return e;if(!Array.isArray(e))return{};let t={};for(let s=0;s<e.length;s+=2)"string"==typeof e[s]&&(t[e[s]]=e[s+1]);return t}var eU=class{baseUrl;headers;options;readYourWrites;upstashSyncToken="";hasCredentials;retry;constructor(e){if(this.options={backend:e.options?.backend,agent:e.agent,responseEncoding:e.responseEncoding??"base64",cache:e.cache,signal:e.signal,keepAlive:e.keepAlive??!0},this.upstashSyncToken="",this.readYourWrites=e.readYourWrites??!0,this.baseUrl=(e.baseUrl||"").replace(/\/$/,""),this.baseUrl&&!/^https?:\/\/[^\s#$./?].\S*$/.test(this.baseUrl))throw new eN(this.baseUrl);this.headers={"Content-Type":"application/json",...e.headers},this.hasCredentials=!!(this.baseUrl&&this.headers.authorization.split(" ")[1]),"base64"===this.options.responseEncoding&&(this.headers["Upstash-Encoding"]="base64"),this.retry="boolean"!=typeof e.retry||e.retry?{attempts:e.retry?.retries??5,backoff:e.retry?.backoff??(e=>50*Math.exp(e))}:{attempts:1,backoff:()=>0}}mergeTelemetry(e){this.headers=eB(this.headers,"Upstash-Telemetry-Runtime",e.runtime),this.headers=eB(this.headers,"Upstash-Telemetry-Platform",e.platform),this.headers=eB(this.headers,"Upstash-Telemetry-Sdk",e.sdk)}async request(e){let t,s=function(...e){let t={};for(let s of e)if(s)for(let[e,n]of Object.entries(s))null!=n&&(t[e]=n);return t}(this.headers,e.headers??{}),n=[this.baseUrl,...e.path??[]].join("/"),i="text/event-stream"===s.Accept,r=e.signal??this.options.signal,o="function"==typeof r,a={cache:this.options.cache,method:"POST",headers:s,body:JSON.stringify(e.body),keepalive:this.options.keepAlive,agent:this.options.agent,signal:o?r():r,backend:this.options.backend};if(this.hasCredentials||console.warn("[Upstash Redis] Redis client was initialized without url or token. Failed to execute command."),this.readYourWrites){let e=this.upstashSyncToken;this.headers["upstash-sync-token"]=e}let c=null,l=null;for(let e=0;e<=this.retry.attempts;e++)try{c=await fetch(n,a);break}catch(t){if(a.signal?.aborted&&o)throw t;if(a.signal?.aborted){c=new Response(new Blob([JSON.stringify({result:a.signal.reason??"Aborted"})]),{status:200,statusText:a.signal.reason??"Aborted"});break}l=t,e<this.retry.attempts&&await new Promise(t=>setTimeout(t,this.retry.backoff(e)))}if(!c)throw l??Error("Exhausted all retries");if(!c.ok){let t,s=await c.text();try{t=JSON.parse(s)}catch(e){throw new e_(s,{cause:e})}throw new eI(`${t.error}, command was: ${JSON.stringify(e.body)}`)}if(this.readYourWrites){let e=c.headers;this.upstashSyncToken=e.get("upstash-sync-token")??""}if(i&&e&&e.onMessage&&c.body){let t=c.body.getReader(),s=new TextDecoder;return(async()=>{try{for(;;){let{value:n,done:i}=await t.read();if(i)break;for(let t of s.decode(n).split("\n"))if(t.startsWith("data: ")){let s=t.slice(6);e.onMessage?.(s)}}}catch(e){e instanceof Error&&"AbortError"===e.name||console.error("Stream reading error:",e)}finally{try{await t.cancel()}catch{}}})(),{result:1}}let h=await c.text();try{t=JSON.parse(h)}catch(e){throw new e_(h,{cause:e})}if(this.readYourWrites){let e=c.headers;this.upstashSyncToken=e.get("upstash-sync-token")??""}return"base64"===this.options.responseEncoding?Array.isArray(t)?t.map(({result:e,error:t})=>({result:eG(e),error:t})):{result:eG(t.result),error:t.error}:t}};function ej(e){let t="";try{let s=atob(e),n=s.length,i=new Uint8Array(n);for(let e=0;e<n;e++)i[e]=s.charCodeAt(e);t=new TextDecoder().decode(i)}catch{t=e}return t}function eG(e){let t;switch(typeof e){case"undefined":return e;case"number":t=e;break;case"object":t=Array.isArray(e)?e.map(e=>"string"==typeof e?ej(e):Array.isArray(e)?e.map(e=>eG(e)):e):null;break;case"string":t="OK"===e?"OK":ej(e)}return t}function eB(e,t,s){return s&&(e[t]=e[t]?[e[t],s].join(","):s),e}var ez=e=>{switch(typeof e){case"string":case"number":case"boolean":return e;default:return JSON.stringify(e)}},eq=class{command;serialize;deserialize;headers;path;onMessage;isStreaming;signal;constructor(e,t){if(this.serialize=ez,this.deserialize=t?.automaticDeserialization===void 0||t.automaticDeserialization?t?.deserialize??eP:e=>e,this.command=e.map(e=>this.serialize(e)),this.headers=t?.headers,this.path=t?.path,this.onMessage=t?.streamOptions?.onMessage,this.isStreaming=t?.streamOptions?.isStreaming??!1,this.signal=t?.streamOptions?.signal,t?.latencyLogging){const e=this.exec.bind(this);this.exec=async t=>{let s=performance.now(),n=await e(t),i=(performance.now()-s).toFixed(2);return console.log(`Latency for \x1b[38;2;19;185;39m${this.command[0].toString().toUpperCase()}\x1b[0m: \x1b[38;2;0;255;255m${i} ms\x1b[0m`),n}}}async exec(e){let{result:t,error:s}=await e.request({body:this.command,path:this.path,upstashSyncToken:e.upstashSyncToken,headers:this.headers,onMessage:this.onMessage,isStreaming:this.isStreaming,signal:this.signal});if(s)throw new eI(s);if(void 0===t)throw TypeError("Request did not return a result");return this.deserialize(t)}},eF=class extends eq{constructor(e,t){const s=["hrandfield",e[0]];"number"==typeof e[1]&&s.push(e[1]),e[2]&&s.push("WITHVALUES"),super(s,{deserialize:e[2]?e=>(function(e){if(0===e.length)return null;let t={};for(let s=0;s<e.length;s+=2){let n=e[s],i=e[s+1];try{t[n]=JSON.parse(i)}catch{t[n]=i}}return t})(e):t?.deserialize,...t})}},eK=class extends eq{constructor(e,t){super(["append",...e],t)}},eH=class extends eq{constructor([e,t,s],n){const i=["bitcount",e];"number"==typeof t&&i.push(t),"number"==typeof s&&i.push(s),super(i,n)}},eW=class{constructor(e,t,s,n=e=>e.exec(this.client)){this.client=t,this.opts=s,this.execOperation=n,this.command=["bitfield",...e]}command;chain(...e){return this.command.push(...e),this}get(...e){return this.chain("get",...e)}set(...e){return this.chain("set",...e)}incrby(...e){return this.chain("incrby",...e)}overflow(e){return this.chain("overflow",e)}exec(){let e=new eq(this.command,this.opts);return this.execOperation(e)}},eY=class extends eq{constructor(e,t){super(["bitop",...e],t)}},e$=class extends eq{constructor(e,t){super(["bitpos",...e],t)}},eV=class extends eq{constructor([e,t,s],n){super(["COPY",e,t,...s?.replace?["REPLACE"]:[]],{...n,deserialize:e=>e>0?"COPIED":"NOT_COPIED"})}},eJ=class extends eq{constructor(e){super(["dbsize"],e)}},eX=class extends eq{constructor(e,t){super(["decr",...e],t)}},eZ=class extends eq{constructor(e,t){super(["decrby",...e],t)}},eQ=class extends eq{constructor(e,t){super(["del",...e],t)}},e0=class extends eq{constructor(e,t){super(["echo",...e],t)}},e1=class extends eq{constructor([e,t,s],n){super(["eval_ro",e,t.length,...t,...s??[]],n)}},e2=class extends eq{constructor([e,t,s],n){super(["eval",e,t.length,...t,...s??[]],n)}},e5=class extends eq{constructor([e,t,s],n){super(["evalsha_ro",e,t.length,...t,...s??[]],n)}},e3=class extends eq{constructor([e,t,s],n){super(["evalsha",e,t.length,...t,...s??[]],n)}},e6=class extends eq{constructor(e,t){super(e.map(e=>"string"==typeof e?e:String(e)),t)}},e4=class extends eq{constructor(e,t){super(["exists",...e],t)}},e8=class extends eq{constructor(e,t){super(["expire",...e.filter(Boolean)],t)}},e7=class extends eq{constructor(e,t){super(["expireat",...e],t)}},e9=class extends eq{constructor([e,t,s],n){super(["fcall",e,...t?[t.length,...t]:[0],...s??[]],n)}},te=class extends eq{constructor([e,t,s],n){super(["fcall_ro",e,...t?[t.length,...t]:[0],...s??[]],n)}},tt=class extends eq{constructor(e,t){const s=["flushall"];e&&e.length>0&&e[0].async&&s.push("async"),super(s,t)}},ts=class extends eq{constructor([e],t){const s=["flushdb"];e?.async&&s.push("async"),super(s,t)}},tn=class extends eq{constructor([e],t){super(["function","delete",e],t)}},ti=class extends eq{constructor(e){super(["function","flush"],e)}},tr=class extends eq{constructor([e],t){const s=["function","list"];e?.libraryName&&s.push("libraryname",e.libraryName),e?.withCode&&s.push("withcode"),super(s,{deserialize:to,...t})}};function to(e){return Array.isArray(e)?e.map(e=>{let t=eD(e),s=t.functions.map(e=>eD(e));return{libraryName:t.library_name,engine:t.engine,functions:s.map(e=>({name:e.name,description:e.description??void 0,flags:e.flags})),libraryCode:t.library_code}}):[]}var ta=class extends eq{constructor([e],t){super(["function","load",...e.replace?["replace"]:[],e.code],t)}},tc=class extends eq{constructor(e){super(["function","stats"],{deserialize:tl,...e})}};function tl(e){return{engines:Object.fromEntries(Object.entries(Object.fromEntries(Object.entries(eD(eD(e).engines)).map(([e,t])=>[e,eD(t)]))).map(([e,t])=>[e,{librariesCount:t.libraries_count,functionsCount:t.functions_count}]))}}var th=class extends eq{constructor([e,t,...s],n){const i=["geoadd",e];"nx"in t&&t.nx?i.push("nx"):"xx"in t&&t.xx&&i.push("xx"),"ch"in t&&t.ch&&i.push("ch"),"latitude"in t&&t.latitude&&i.push(t.longitude,t.latitude,t.member),i.push(...s.flatMap(({latitude:e,longitude:t,member:s})=>[t,e,s])),super(i,n)}},tu=class extends eq{constructor([e,t,s,n="M"],i){super(["GEODIST",e,t,s,n],i)}},tp=class extends eq{constructor(e,t){const[s]=e;super(["GEOHASH",s,...Array.isArray(e[1])?e[1]:e.slice(1)],t)}},td=class extends eq{constructor(e,t){const[s]=e;super(["GEOPOS",s,...Array.isArray(e[1])?e[1]:e.slice(1)],{deserialize:e=>(function(e){let t=[];for(let s of e)s?.[0]&&s?.[1]&&t.push({lng:Number.parseFloat(s[0]),lat:Number.parseFloat(s[1])});return t})(e),...t})}},tm=class extends eq{constructor([e,t,s,n,i],r){const o=["GEOSEARCH",e];("FROMMEMBER"===t.type||"frommember"===t.type)&&o.push(t.type,t.member),("FROMLONLAT"===t.type||"fromlonlat"===t.type)&&o.push(t.type,t.coordinate.lon,t.coordinate.lat),("BYRADIUS"===s.type||"byradius"===s.type)&&o.push(s.type,s.radius,s.radiusType),("BYBOX"===s.type||"bybox"===s.type)&&o.push(s.type,s.rect.width,s.rect.height,s.rectType),o.push(n),i?.count&&o.push("COUNT",i.count.limit,...i.count.any?["ANY"]:[]),super([...o,...i?.withCoord?["WITHCOORD"]:[],...i?.withDist?["WITHDIST"]:[],...i?.withHash?["WITHHASH"]:[]],{deserialize:e=>i?.withCoord||i?.withDist||i?.withHash?e.map(e=>{let t=1,s={};try{s.member=JSON.parse(e[0])}catch{s.member=e[0]}return i.withDist&&(s.dist=Number.parseFloat(e[t++])),i.withHash&&(s.hash=e[t++].toString()),i.withCoord&&(s.coord={long:Number.parseFloat(e[t][0]),lat:Number.parseFloat(e[t][1])}),s}):e.map(e=>{try{return{member:JSON.parse(e)}}catch{return{member:e}}}),...r})}},tw=class extends eq{constructor([e,t,s,n,i,r],o){const a=["GEOSEARCHSTORE",e,t];("FROMMEMBER"===s.type||"frommember"===s.type)&&a.push(s.type,s.member),("FROMLONLAT"===s.type||"fromlonlat"===s.type)&&a.push(s.type,s.coordinate.lon,s.coordinate.lat),("BYRADIUS"===n.type||"byradius"===n.type)&&a.push(n.type,n.radius,n.radiusType),("BYBOX"===n.type||"bybox"===n.type)&&a.push(n.type,n.rect.width,n.rect.height,n.rectType),a.push(i),r?.count&&a.push("COUNT",r.count.limit,...r.count.any?["ANY"]:[]),super([...a,...r?.storeDist?["STOREDIST"]:[]],o)}},tf=class extends eq{constructor(e,t){super(["get",...e],t)}},tg=class extends eq{constructor(e,t){super(["getbit",...e],t)}},tx=class extends eq{constructor(e,t){super(["getdel",...e],t)}},ty=class extends eq{constructor([e,t],s){const n=["getex",e];t&&("ex"in t&&"number"==typeof t.ex?n.push("ex",t.ex):"px"in t&&"number"==typeof t.px?n.push("px",t.px):"exat"in t&&"number"==typeof t.exat?n.push("exat",t.exat):"pxat"in t&&"number"==typeof t.pxat?n.push("pxat",t.pxat):"persist"in t&&t.persist&&n.push("persist")),super(n,s)}},tb=class extends eq{constructor(e,t){super(["getrange",...e],t)}},tE=class extends eq{constructor(e,t){super(["getset",...e],t)}},tO=class extends eq{constructor(e,t){super(["hdel",...e],t)}},tR=class extends eq{constructor(e,t){super(["hexists",...e],t)}},tv=class extends eq{constructor(e,t){const[s,n,i,r]=e,o=Array.isArray(n)?n:[n];super(["hexpire",s,i,...r?[r]:[],"FIELDS",o.length,...o],t)}},tA=class extends eq{constructor(e,t){const[s,n,i,r]=e,o=Array.isArray(n)?n:[n];super(["hexpireat",s,i,...r?[r]:[],"FIELDS",o.length,...o],t)}},tT=class extends eq{constructor(e,t){const[s,n]=e,i=Array.isArray(n)?n:[n];super(["hexpiretime",s,"FIELDS",i.length,...i],t)}},tS=class extends eq{constructor(e,t){const[s,n]=e,i=Array.isArray(n)?n:[n];super(["hpersist",s,"FIELDS",i.length,...i],t)}},tC=class extends eq{constructor(e,t){const[s,n,i,r]=e,o=Array.isArray(n)?n:[n];super(["hpexpire",s,i,...r?[r]:[],"FIELDS",o.length,...o],t)}},tk=class extends eq{constructor(e,t){const[s,n,i,r]=e,o=Array.isArray(n)?n:[n];super(["hpexpireat",s,i,...r?[r]:[],"FIELDS",o.length,...o],t)}},tI=class extends eq{constructor(e,t){const[s,n]=e,i=Array.isArray(n)?n:[n];super(["hpexpiretime",s,"FIELDS",i.length,...i],t)}},tN=class extends eq{constructor(e,t){const[s,n]=e,i=Array.isArray(n)?n:[n];super(["hpttl",s,"FIELDS",i.length,...i],t)}},t_=class extends eq{constructor(e,t){super(["hget",...e],t)}},tP=class extends eq{constructor(e,t){super(["hgetall",...e],{deserialize:e=>(function(e){if(0===e.length)return null;let t={};for(let s=0;s<e.length;s+=2){let n=e[s],i=e[s+1];try{let e=!Number.isNaN(Number(i))&&!Number.isSafeInteger(Number(i));t[n]=e?i:JSON.parse(i)}catch{t[n]=i}}return t})(e),...t})}},tM=class extends eq{constructor(e,t){super(["hincrby",...e],t)}},tL=class extends eq{constructor(e,t){super(["hincrbyfloat",...e],t)}},tD=class extends eq{constructor([e],t){super(["hkeys",e],t)}},tU=class extends eq{constructor(e,t){super(["hlen",...e],t)}},tj=class extends eq{constructor([e,...t],s){super(["hmget",e,...t],{deserialize:e=>(function(e,t){if(t.every(e=>null===e))return null;let s={};for(let[n,i]of e.entries())try{s[i]=JSON.parse(t[n])}catch{s[i]=t[n]}return s})(t,e),...s})}},tG=class extends eq{constructor([e,t],s){super(["hmset",e,...Object.entries(t).flatMap(([e,t])=>[e,t])],s)}},tB=class extends eq{constructor([e,t,s],n){const i=["hscan",e,t];s?.match&&i.push("match",s.match),"number"==typeof s?.count&&i.push("count",s.count),super(i,{deserialize:eM,...n})}},tz=class extends eq{constructor([e,t],s){super(["hset",e,...Object.entries(t).flatMap(([e,t])=>[e,t])],s)}},tq=class extends eq{constructor(e,t){super(["hsetnx",...e],t)}},tF=class extends eq{constructor(e,t){super(["hstrlen",...e],t)}},tK=class extends eq{constructor(e,t){const[s,n]=e,i=Array.isArray(n)?n:[n];super(["httl",s,"FIELDS",i.length,...i],t)}},tH=class extends eq{constructor(e,t){super(["hvals",...e],t)}},tW=class extends eq{constructor(e,t){super(["incr",...e],t)}},tY=class extends eq{constructor(e,t){super(["incrby",...e],t)}},t$=class extends eq{constructor(e,t){super(["incrbyfloat",...e],t)}},tV=class extends eq{constructor(e,t){super(["JSON.ARRAPPEND",...e],t)}},tJ=class extends eq{constructor(e,t){super(["JSON.ARRINDEX",...e],t)}},tX=class extends eq{constructor(e,t){super(["JSON.ARRINSERT",...e],t)}},tZ=class extends eq{constructor(e,t){super(["JSON.ARRLEN",e[0],e[1]??"$"],t)}},tQ=class extends eq{constructor(e,t){super(["JSON.ARRPOP",...e],t)}},t0=class extends eq{constructor(e,t){const s=e[1]??"$";super(["JSON.ARRTRIM",e[0],s,e[2]??0,e[3]??0],t)}},t1=class extends eq{constructor(e,t){super(["JSON.CLEAR",...e],t)}},t2=class extends eq{constructor(e,t){super(["JSON.DEL",...e],t)}},t5=class extends eq{constructor(e,t){super(["JSON.FORGET",...e],t)}},t3=class extends eq{constructor(e,t){const s=["JSON.GET"];"string"==typeof e[1]?s.push(...e):(s.push(e[0]),e[1]&&(e[1].indent&&s.push("INDENT",e[1].indent),e[1].newline&&s.push("NEWLINE",e[1].newline),e[1].space&&s.push("SPACE",e[1].space)),s.push(...e.slice(2))),super(s,t)}},t6=class extends eq{constructor(e,t){super(["JSON.MERGE",...e],t)}},t4=class extends eq{constructor(e,t){super(["JSON.MGET",...e[0],e[1]],t)}},t8=class extends eq{constructor(e,t){const s=["JSON.MSET"];for(const t of e)s.push(t.key,t.path,t.value);super(s,t)}},t7=class extends eq{constructor(e,t){super(["JSON.NUMINCRBY",...e],t)}},t9=class extends eq{constructor(e,t){super(["JSON.NUMMULTBY",...e],t)}},se=class extends eq{constructor(e,t){super(["JSON.OBJKEYS",...e],t)}},st=class extends eq{constructor(e,t){super(["JSON.OBJLEN",...e],t)}},ss=class extends eq{constructor(e,t){super(["JSON.RESP",...e],t)}},sn=class extends eq{constructor(e,t){const s=["JSON.SET",e[0],e[1],e[2]];e[3]&&(e[3].nx?s.push("NX"):e[3].xx&&s.push("XX")),super(s,t)}},si=class extends eq{constructor(e,t){super(["JSON.STRAPPEND",...e],t)}},sr=class extends eq{constructor(e,t){super(["JSON.STRLEN",...e],t)}},so=class extends eq{constructor(e,t){super(["JSON.TOGGLE",...e],t)}},sa=class extends eq{constructor(e,t){super(["JSON.TYPE",...e],t)}},sc=class extends eq{constructor(e,t){super(["keys",...e],t)}},sl=class extends eq{constructor(e,t){super(["lindex",...e],t)}},sh=class extends eq{constructor(e,t){super(["linsert",...e],t)}},su=class extends eq{constructor(e,t){super(["llen",...e],t)}},sp=class extends eq{constructor(e,t){super(["lmove",...e],t)}},sd=class extends eq{constructor(e,t){const[s,n,i,r]=e;super(["LMPOP",s,...n,i,...r?["COUNT",r]:[]],t)}},sm=class extends eq{constructor(e,t){super(["lpop",...e],t)}},sw=class extends eq{constructor(e,t){const s=["lpos",e[0],e[1]];"number"==typeof e[2]?.rank&&s.push("rank",e[2].rank),"number"==typeof e[2]?.count&&s.push("count",e[2].count),"number"==typeof e[2]?.maxLen&&s.push("maxLen",e[2].maxLen),super(s,t)}},sf=class extends eq{constructor(e,t){super(["lpush",...e],t)}},sg=class extends eq{constructor(e,t){super(["lpushx",...e],t)}},sx=class extends eq{constructor(e,t){super(["lrange",...e],t)}},sy=class extends eq{constructor(e,t){super(["lrem",...e],t)}},sb=class extends eq{constructor(e,t){super(["lset",...e],t)}},sE=class extends eq{constructor(e,t){super(["ltrim",...e],t)}},sO=class extends eq{constructor(e,t){super(["mget",...Array.isArray(e[0])?e[0]:e],t)}},sR=class extends eq{constructor([e],t){super(["mset",...Object.entries(e).flatMap(([e,t])=>[e,t])],t)}},sv=class extends eq{constructor([e],t){super(["msetnx",...Object.entries(e).flat()],t)}},sA=class extends eq{constructor(e,t){super(["persist",...e],t)}},sT=class extends eq{constructor(e,t){super(["pexpire",...e],t)}},sS=class extends eq{constructor(e,t){super(["pexpireat",...e],t)}},sC=class extends eq{constructor(e,t){super(["pfadd",...e],t)}},sk=class extends eq{constructor(e,t){super(["pfcount",...e],t)}},sI=class extends eq{constructor(e,t){super(["pfmerge",...e],t)}},sN=class extends eq{constructor(e,t){const s=["ping"];e?.[0]!==void 0&&s.push(e[0]),super(s,t)}},s_=class extends eq{constructor(e,t){super(["psetex",...e],t)}},sP=class extends eq{constructor(e,t){super(["pttl",...e],t)}},sM=class extends eq{constructor(e,t){super(["publish",...e],t)}},sL=class extends eq{constructor(e){super(["randomkey"],e)}},sD=class extends eq{constructor(e,t){super(["rename",...e],t)}},sU=class extends eq{constructor(e,t){super(["renamenx",...e],t)}},sj=class extends eq{constructor(e,t){super(["rpop",...e],t)}},sG=class extends eq{constructor(e,t){super(["rpush",...e],t)}},sB=class extends eq{constructor(e,t){super(["rpushx",...e],t)}},sz=class extends eq{constructor(e,t){super(["sadd",...e],t)}},sq=class extends eq{constructor([e,t],s){const n=["scan",e];t?.match&&n.push("match",t.match),"number"==typeof t?.count&&n.push("count",t.count),t&&"withType"in t&&!0===t.withType?n.push("withtype"):t&&"type"in t&&t.type&&t.type.length>0&&n.push("type",t.type),super(n,{deserialize:t?.withType?eL:eM,...s})}},sF=class extends eq{constructor(e,t){super(["scard",...e],t)}},sK=class extends eq{constructor(e,t){super(["script","exists",...e],{deserialize:e=>e,...t})}},sH=class extends eq{constructor([e],t){const s=["script","flush"];e?.sync?s.push("sync"):e?.async&&s.push("async"),super(s,t)}},sW=class extends eq{constructor(e,t){super(["script","load",...e],t)}},sY=class extends eq{constructor(e,t){super(["sdiff",...e],t)}},s$=class extends eq{constructor(e,t){super(["sdiffstore",...e],t)}},sV=class extends eq{constructor([e,t,s],n){const i=["set",e,t];s&&("nx"in s&&s.nx?i.push("nx"):"xx"in s&&s.xx&&i.push("xx"),"get"in s&&s.get&&i.push("get"),"ex"in s&&"number"==typeof s.ex?i.push("ex",s.ex):"px"in s&&"number"==typeof s.px?i.push("px",s.px):"exat"in s&&"number"==typeof s.exat?i.push("exat",s.exat):"pxat"in s&&"number"==typeof s.pxat?i.push("pxat",s.pxat):"keepTtl"in s&&s.keepTtl&&i.push("keepTtl")),super(i,n)}},sJ=class extends eq{constructor(e,t){super(["setbit",...e],t)}},sX=class extends eq{constructor(e,t){super(["setex",...e],t)}},sZ=class extends eq{constructor(e,t){super(["setnx",...e],t)}},sQ=class extends eq{constructor(e,t){super(["setrange",...e],t)}},s0=class extends eq{constructor(e,t){super(["sinter",...e],t)}},s1=class extends eq{constructor(e,t){super(["sinterstore",...e],t)}},s2=class extends eq{constructor(e,t){super(["sismember",...e],t)}},s5=class extends eq{constructor(e,t){super(["smembers",...e],t)}},s3=class extends eq{constructor(e,t){super(["smismember",e[0],...e[1]],t)}},s6=class extends eq{constructor(e,t){super(["smove",...e],t)}},s4=class extends eq{constructor([e,t],s){const n=["spop",e];"number"==typeof t&&n.push(t),super(n,s)}},s8=class extends eq{constructor([e,t],s){const n=["srandmember",e];"number"==typeof t&&n.push(t),super(n,s)}},s7=class extends eq{constructor(e,t){super(["srem",...e],t)}},s9=class extends eq{constructor([e,t,s],n){const i=["sscan",e,t];s?.match&&i.push("match",s.match),"number"==typeof s?.count&&i.push("count",s.count),super(i,{deserialize:eM,...n})}},ne=class extends eq{constructor(e,t){super(["strlen",...e],t)}},nt=class extends eq{constructor(e,t){super(["sunion",...e],t)}},ns=class extends eq{constructor(e,t){super(["sunionstore",...e],t)}},nn=class extends eq{constructor(e){super(["time"],e)}},ni=class extends eq{constructor(e,t){super(["touch",...e],t)}},nr=class extends eq{constructor(e,t){super(["ttl",...e],t)}},no=class extends eq{constructor(e,t){super(["type",...e],t)}},na=class extends eq{constructor(e,t){super(["unlink",...e],t)}},nc=class extends eq{constructor([e,t,s],n){super(["XACK",e,t,...Array.isArray(s)?[...s]:[s]],n)}},nl=class extends eq{constructor([e,t,s,n],i){const r=["XADD",e];for(const[e,i]of(n&&(n.nomkStream&&r.push("NOMKSTREAM"),n.trim&&(r.push(n.trim.type,n.trim.comparison,n.trim.threshold),void 0!==n.trim.limit&&r.push("LIMIT",n.trim.limit))),r.push(t),Object.entries(s)))r.push(e,i);super(r,i)}},nh=class extends eq{constructor([e,t,s,n,i,r],o){const a=[];r?.count&&a.push("COUNT",r.count),r?.justId&&a.push("JUSTID"),super(["XAUTOCLAIM",e,t,s,n,i,...a],o)}},nu=class extends eq{constructor([e,t,s,n,i,r],o){const a=Array.isArray(i)?[...i]:[i],c=[];r?.idleMS&&c.push("IDLE",r.idleMS),r?.idleMS&&c.push("TIME",r.timeMS),r?.retryCount&&c.push("RETRYCOUNT",r.retryCount),r?.force&&c.push("FORCE"),r?.justId&&c.push("JUSTID"),r?.lastId&&c.push("LASTID",r.lastId),super(["XCLAIM",e,t,s,n,...a,...c],o)}},np=class extends eq{constructor([e,t],s){super(["XDEL",e,...Array.isArray(t)?[...t]:[t]],s)}},nd=class extends eq{constructor([e,t],s){const n=["XGROUP"];switch(t.type){case"CREATE":n.push("CREATE",e,t.group,t.id),t.options&&(t.options.MKSTREAM&&n.push("MKSTREAM"),void 0!==t.options.ENTRIESREAD&&n.push("ENTRIESREAD",t.options.ENTRIESREAD.toString()));break;case"CREATECONSUMER":n.push("CREATECONSUMER",e,t.group,t.consumer);break;case"DELCONSUMER":n.push("DELCONSUMER",e,t.group,t.consumer);break;case"DESTROY":n.push("DESTROY",e,t.group);break;case"SETID":n.push("SETID",e,t.group,t.id),t.options?.ENTRIESREAD!==void 0&&n.push("ENTRIESREAD",t.options.ENTRIESREAD.toString());break;default:throw Error("Invalid XGROUP")}super(n,s)}},nm=class extends eq{constructor([e,t],s){const n=[];"CONSUMERS"===t.type?n.push("CONSUMERS",e,t.group):n.push("GROUPS",e),super(["XINFO",...n],s)}},nw=class extends eq{constructor(e,t){super(["XLEN",...e],t)}},nf=class extends eq{constructor([e,t,s,n,i,r],o){super(["XPENDING",e,t,...r?.idleTime?["IDLE",r.idleTime]:[],s,n,i,...r?.consumer===void 0?[]:Array.isArray(r.consumer)?[...r.consumer]:[r.consumer]],o)}},ng=class extends eq{constructor([e,t,s,n],i){const r=["XRANGE",e,t,s];"number"==typeof n&&r.push("COUNT",n),super(r,{deserialize:e=>(function(e){let t={};for(let s of e)for(let e=0;e<s.length;e+=2){let n=s[e],i=s[e+1];n in t||(t[n]={});for(let e=0;e<i.length;e+=2){let s=i[e],r=i[e+1];try{t[n][s]=JSON.parse(r)}catch{t[n][s]=r}}}return t})(e),...i})}},nx=class extends eq{constructor([e,t,s],n){if(Array.isArray(e)&&Array.isArray(t)&&e.length!==t.length)throw Error("ERR Unbalanced XREAD list of streams: for each stream key an ID or '$' must be specified");const i=[];"number"==typeof s?.count&&i.push("COUNT",s.count),"number"==typeof s?.blockMS&&i.push("BLOCK",s.blockMS),i.push("STREAMS",...Array.isArray(e)?[...e]:[e],...Array.isArray(t)?[...t]:[t]),super(["XREAD",...i],n)}},ny=class extends eq{constructor([e,t,s,n,i],r){if(Array.isArray(s)&&Array.isArray(n)&&s.length!==n.length)throw Error("ERR Unbalanced XREADGROUP list of streams: for each stream key an ID or '$' must be specified");const o=[];"number"==typeof i?.count&&o.push("COUNT",i.count),"number"==typeof i?.blockMS&&o.push("BLOCK",i.blockMS),"boolean"==typeof i?.NOACK&&i.NOACK&&o.push("NOACK"),o.push("STREAMS",...Array.isArray(s)?[...s]:[s],...Array.isArray(n)?[...n]:[n]),super(["XREADGROUP","GROUP",e,t,...o],r)}},nb=class extends eq{constructor([e,t,s,n],i){const r=["XREVRANGE",e,t,s];"number"==typeof n&&r.push("COUNT",n),super(r,{deserialize:e=>(function(e){let t={};for(let s of e)for(let e=0;e<s.length;e+=2){let n=s[e],i=s[e+1];n in t||(t[n]={});for(let e=0;e<i.length;e+=2){let s=i[e],r=i[e+1];try{t[n][s]=JSON.parse(r)}catch{t[n][s]=r}}}return t})(e),...i})}},nE=class extends eq{constructor([e,t],s){const{limit:n,strategy:i,threshold:r,exactness:o="~"}=t;super(["XTRIM",e,i,o,r,...n?["LIMIT",n]:[]],s)}},nO=class extends eq{constructor([e,t,...s],n){const i=["zadd",e];"nx"in t&&t.nx?i.push("nx"):"xx"in t&&t.xx&&i.push("xx"),"ch"in t&&t.ch&&i.push("ch"),"incr"in t&&t.incr&&i.push("incr"),"lt"in t&&t.lt?i.push("lt"):"gt"in t&&t.gt&&i.push("gt"),"score"in t&&"member"in t&&i.push(t.score,t.member),i.push(...s.flatMap(({score:e,member:t})=>[e,t])),super(i,n)}},nR=class extends eq{constructor(e,t){super(["zcard",...e],t)}},nv=class extends eq{constructor(e,t){super(["zcount",...e],t)}},nA=class extends eq{constructor(e,t){super(["zincrby",...e],t)}},nT=class extends eq{constructor([e,t,s,n],i){const r=["zinterstore",e,t];Array.isArray(s)?r.push(...s):r.push(s),n&&("weights"in n&&n.weights?r.push("weights",...n.weights):"weight"in n&&"number"==typeof n.weight&&r.push("weights",n.weight),"aggregate"in n&&r.push("aggregate",n.aggregate)),super(r,i)}},nS=class extends eq{constructor(e,t){super(["zlexcount",...e],t)}},nC=class extends eq{constructor([e,t],s){const n=["zpopmax",e];"number"==typeof t&&n.push(t),super(n,s)}},nk=class extends eq{constructor([e,t],s){const n=["zpopmin",e];"number"==typeof t&&n.push(t),super(n,s)}},nI=class extends eq{constructor([e,t,s,n],i){const r=["zrange",e,t,s];n?.byScore&&r.push("byscore"),n?.byLex&&r.push("bylex"),n?.rev&&r.push("rev"),n?.count!==void 0&&void 0!==n.offset&&r.push("limit",n.offset,n.count),n?.withScores&&r.push("withscores"),super(r,i)}},nN=class extends eq{constructor(e,t){super(["zrank",...e],t)}},n_=class extends eq{constructor(e,t){super(["zrem",...e],t)}},nP=class extends eq{constructor(e,t){super(["zremrangebylex",...e],t)}},nM=class extends eq{constructor(e,t){super(["zremrangebyrank",...e],t)}},nL=class extends eq{constructor(e,t){super(["zremrangebyscore",...e],t)}},nD=class extends eq{constructor(e,t){super(["zrevrank",...e],t)}},nU=class extends eq{constructor([e,t,s],n){const i=["zscan",e,t];s?.match&&i.push("match",s.match),"number"==typeof s?.count&&i.push("count",s.count),super(i,{deserialize:eM,...n})}},nj=class extends eq{constructor(e,t){super(["zscore",...e],t)}},nG=class extends eq{constructor([e,t,s],n){const i=["zunion",e];Array.isArray(t)?i.push(...t):i.push(t),s&&("weights"in s&&s.weights?i.push("weights",...s.weights):"weight"in s&&"number"==typeof s.weight&&i.push("weights",s.weight),"aggregate"in s&&i.push("aggregate",s.aggregate),s.withScores&&i.push("withscores")),super(i,n)}},nB=class extends eq{constructor([e,t,s,n],i){const r=["zunionstore",e,t];Array.isArray(s)?r.push(...s):r.push(s),n&&("weights"in n&&n.weights?r.push("weights",...n.weights):"weight"in n&&"number"==typeof n.weight&&r.push("weights",n.weight),"aggregate"in n&&r.push("aggregate",n.aggregate)),super(r,i)}},nz=class extends eq{constructor(e,t){super(["zdiffstore",...e],t)}},nq=class extends eq{constructor(e,t){const[s,n]=e;super(["zmscore",s,...n],t)}},nF=class{client;commands;commandOptions;multiExec;constructor(e){if(this.client=e.client,this.commands=[],this.commandOptions=e.commandOptions,this.multiExec=e.multiExec??!1,this.commandOptions?.latencyLogging){const e=this.exec.bind(this);this.exec=async t=>{let s=performance.now(),n=await (t?e(t):e()),i=(performance.now()-s).toFixed(2);return console.log(`Latency for \x1b[38;2;19;185;39m${this.multiExec?["MULTI-EXEC"]:["PIPELINE"].toString().toUpperCase()}\x1b[0m: \x1b[38;2;0;255;255m${i} ms\x1b[0m`),n}}}exec=async e=>{if(0===this.commands.length)throw Error("Pipeline is empty");let t=this.multiExec?["multi-exec"]:["pipeline"],s=await this.client.request({path:t,body:Object.values(this.commands).map(e=>e.command)});return e?.keepErrors?s.map(({error:e,result:t},s)=>({error:e,result:this.commands[s].deserialize(t)})):s.map(({error:e,result:t},s)=>{if(e)throw new eI(`Command ${s+1} [ ${this.commands[s].command[0]} ] failed: ${e}`);return this.commands[s].deserialize(t)})};length(){return this.commands.length}chain(e){return this.commands.push(e),this}append=(...e)=>this.chain(new eK(e,this.commandOptions));bitcount=(...e)=>this.chain(new eH(e,this.commandOptions));bitfield=(...e)=>new eW(e,this.client,this.commandOptions,this.chain.bind(this));bitop=(e,t,s,...n)=>this.chain(new eY([e,t,s,...n],this.commandOptions));bitpos=(...e)=>this.chain(new e$(e,this.commandOptions));copy=(...e)=>this.chain(new eV(e,this.commandOptions));zdiffstore=(...e)=>this.chain(new nz(e,this.commandOptions));dbsize=()=>this.chain(new eJ(this.commandOptions));decr=(...e)=>this.chain(new eX(e,this.commandOptions));decrby=(...e)=>this.chain(new eZ(e,this.commandOptions));del=(...e)=>this.chain(new eQ(e,this.commandOptions));echo=(...e)=>this.chain(new e0(e,this.commandOptions));evalRo=(...e)=>this.chain(new e1(e,this.commandOptions));eval=(...e)=>this.chain(new e2(e,this.commandOptions));evalshaRo=(...e)=>this.chain(new e5(e,this.commandOptions));evalsha=(...e)=>this.chain(new e3(e,this.commandOptions));exists=(...e)=>this.chain(new e4(e,this.commandOptions));expire=(...e)=>this.chain(new e8(e,this.commandOptions));expireat=(...e)=>this.chain(new e7(e,this.commandOptions));flushall=e=>this.chain(new tt(e,this.commandOptions));flushdb=(...e)=>this.chain(new ts(e,this.commandOptions));geoadd=(...e)=>this.chain(new th(e,this.commandOptions));geodist=(...e)=>this.chain(new tu(e,this.commandOptions));geopos=(...e)=>this.chain(new td(e,this.commandOptions));geohash=(...e)=>this.chain(new tp(e,this.commandOptions));geosearch=(...e)=>this.chain(new tm(e,this.commandOptions));geosearchstore=(...e)=>this.chain(new tw(e,this.commandOptions));get=(...e)=>this.chain(new tf(e,this.commandOptions));getbit=(...e)=>this.chain(new tg(e,this.commandOptions));getdel=(...e)=>this.chain(new tx(e,this.commandOptions));getex=(...e)=>this.chain(new ty(e,this.commandOptions));getrange=(...e)=>this.chain(new tb(e,this.commandOptions));getset=(e,t)=>this.chain(new tE([e,t],this.commandOptions));hdel=(...e)=>this.chain(new tO(e,this.commandOptions));hexists=(...e)=>this.chain(new tR(e,this.commandOptions));hexpire=(...e)=>this.chain(new tv(e,this.commandOptions));hexpireat=(...e)=>this.chain(new tA(e,this.commandOptions));hexpiretime=(...e)=>this.chain(new tT(e,this.commandOptions));httl=(...e)=>this.chain(new tK(e,this.commandOptions));hpexpire=(...e)=>this.chain(new tC(e,this.commandOptions));hpexpireat=(...e)=>this.chain(new tk(e,this.commandOptions));hpexpiretime=(...e)=>this.chain(new tI(e,this.commandOptions));hpttl=(...e)=>this.chain(new tN(e,this.commandOptions));hpersist=(...e)=>this.chain(new tS(e,this.commandOptions));hget=(...e)=>this.chain(new t_(e,this.commandOptions));hgetall=(...e)=>this.chain(new tP(e,this.commandOptions));hincrby=(...e)=>this.chain(new tM(e,this.commandOptions));hincrbyfloat=(...e)=>this.chain(new tL(e,this.commandOptions));hkeys=(...e)=>this.chain(new tD(e,this.commandOptions));hlen=(...e)=>this.chain(new tU(e,this.commandOptions));hmget=(...e)=>this.chain(new tj(e,this.commandOptions));hmset=(e,t)=>this.chain(new tG([e,t],this.commandOptions));hrandfield=(e,t,s)=>this.chain(new eF([e,t,s],this.commandOptions));hscan=(...e)=>this.chain(new tB(e,this.commandOptions));hset=(e,t)=>this.chain(new tz([e,t],this.commandOptions));hsetnx=(e,t,s)=>this.chain(new tq([e,t,s],this.commandOptions));hstrlen=(...e)=>this.chain(new tF(e,this.commandOptions));hvals=(...e)=>this.chain(new tH(e,this.commandOptions));incr=(...e)=>this.chain(new tW(e,this.commandOptions));incrby=(...e)=>this.chain(new tY(e,this.commandOptions));incrbyfloat=(...e)=>this.chain(new t$(e,this.commandOptions));keys=(...e)=>this.chain(new sc(e,this.commandOptions));lindex=(...e)=>this.chain(new sl(e,this.commandOptions));linsert=(e,t,s,n)=>this.chain(new sh([e,t,s,n],this.commandOptions));llen=(...e)=>this.chain(new su(e,this.commandOptions));lmove=(...e)=>this.chain(new sp(e,this.commandOptions));lpop=(...e)=>this.chain(new sm(e,this.commandOptions));lmpop=(...e)=>this.chain(new sd(e,this.commandOptions));lpos=(...e)=>this.chain(new sw(e,this.commandOptions));lpush=(e,...t)=>this.chain(new sf([e,...t],this.commandOptions));lpushx=(e,...t)=>this.chain(new sg([e,...t],this.commandOptions));lrange=(...e)=>this.chain(new sx(e,this.commandOptions));lrem=(e,t,s)=>this.chain(new sy([e,t,s],this.commandOptions));lset=(e,t,s)=>this.chain(new sb([e,t,s],this.commandOptions));ltrim=(...e)=>this.chain(new sE(e,this.commandOptions));mget=(...e)=>this.chain(new sO(e,this.commandOptions));mset=e=>this.chain(new sR([e],this.commandOptions));msetnx=e=>this.chain(new sv([e],this.commandOptions));persist=(...e)=>this.chain(new sA(e,this.commandOptions));pexpire=(...e)=>this.chain(new sT(e,this.commandOptions));pexpireat=(...e)=>this.chain(new sS(e,this.commandOptions));pfadd=(...e)=>this.chain(new sC(e,this.commandOptions));pfcount=(...e)=>this.chain(new sk(e,this.commandOptions));pfmerge=(...e)=>this.chain(new sI(e,this.commandOptions));ping=e=>this.chain(new sN(e,this.commandOptions));psetex=(e,t,s)=>this.chain(new s_([e,t,s],this.commandOptions));pttl=(...e)=>this.chain(new sP(e,this.commandOptions));publish=(...e)=>this.chain(new sM(e,this.commandOptions));randomkey=()=>this.chain(new sL(this.commandOptions));rename=(...e)=>this.chain(new sD(e,this.commandOptions));renamenx=(...e)=>this.chain(new sU(e,this.commandOptions));rpop=(...e)=>this.chain(new sj(e,this.commandOptions));rpush=(e,...t)=>this.chain(new sG([e,...t],this.commandOptions));rpushx=(e,...t)=>this.chain(new sB([e,...t],this.commandOptions));sadd=(e,t,...s)=>this.chain(new sz([e,t,...s],this.commandOptions));scan=(...e)=>this.chain(new sq(e,this.commandOptions));scard=(...e)=>this.chain(new sF(e,this.commandOptions));scriptExists=(...e)=>this.chain(new sK(e,this.commandOptions));scriptFlush=(...e)=>this.chain(new sH(e,this.commandOptions));scriptLoad=(...e)=>this.chain(new sW(e,this.commandOptions));sdiff=(...e)=>this.chain(new sY(e,this.commandOptions));sdiffstore=(...e)=>this.chain(new s$(e,this.commandOptions));set=(e,t,s)=>this.chain(new sV([e,t,s],this.commandOptions));setbit=(...e)=>this.chain(new sJ(e,this.commandOptions));setex=(e,t,s)=>this.chain(new sX([e,t,s],this.commandOptions));setnx=(e,t)=>this.chain(new sZ([e,t],this.commandOptions));setrange=(...e)=>this.chain(new sQ(e,this.commandOptions));sinter=(...e)=>this.chain(new s0(e,this.commandOptions));sinterstore=(...e)=>this.chain(new s1(e,this.commandOptions));sismember=(e,t)=>this.chain(new s2([e,t],this.commandOptions));smembers=(...e)=>this.chain(new s5(e,this.commandOptions));smismember=(e,t)=>this.chain(new s3([e,t],this.commandOptions));smove=(e,t,s)=>this.chain(new s6([e,t,s],this.commandOptions));spop=(...e)=>this.chain(new s4(e,this.commandOptions));srandmember=(...e)=>this.chain(new s8(e,this.commandOptions));srem=(e,...t)=>this.chain(new s7([e,...t],this.commandOptions));sscan=(...e)=>this.chain(new s9(e,this.commandOptions));strlen=(...e)=>this.chain(new ne(e,this.commandOptions));sunion=(...e)=>this.chain(new nt(e,this.commandOptions));sunionstore=(...e)=>this.chain(new ns(e,this.commandOptions));time=()=>this.chain(new nn(this.commandOptions));touch=(...e)=>this.chain(new ni(e,this.commandOptions));ttl=(...e)=>this.chain(new nr(e,this.commandOptions));type=(...e)=>this.chain(new no(e,this.commandOptions));unlink=(...e)=>this.chain(new na(e,this.commandOptions));zadd=(...e)=>("score"in e[1],this.chain(new nO([e[0],e[1],...e.slice(2)],this.commandOptions)));xadd=(...e)=>this.chain(new nl(e,this.commandOptions));xack=(...e)=>this.chain(new nc(e,this.commandOptions));xdel=(...e)=>this.chain(new np(e,this.commandOptions));xgroup=(...e)=>this.chain(new nd(e,this.commandOptions));xread=(...e)=>this.chain(new nx(e,this.commandOptions));xreadgroup=(...e)=>this.chain(new ny(e,this.commandOptions));xinfo=(...e)=>this.chain(new nm(e,this.commandOptions));xlen=(...e)=>this.chain(new nw(e,this.commandOptions));xpending=(...e)=>this.chain(new nf(e,this.commandOptions));xclaim=(...e)=>this.chain(new nu(e,this.commandOptions));xautoclaim=(...e)=>this.chain(new nh(e,this.commandOptions));xtrim=(...e)=>this.chain(new nE(e,this.commandOptions));xrange=(...e)=>this.chain(new ng(e,this.commandOptions));xrevrange=(...e)=>this.chain(new nb(e,this.commandOptions));zcard=(...e)=>this.chain(new nR(e,this.commandOptions));zcount=(...e)=>this.chain(new nv(e,this.commandOptions));zincrby=(e,t,s)=>this.chain(new nA([e,t,s],this.commandOptions));zinterstore=(...e)=>this.chain(new nT(e,this.commandOptions));zlexcount=(...e)=>this.chain(new nS(e,this.commandOptions));zmscore=(...e)=>this.chain(new nq(e,this.commandOptions));zpopmax=(...e)=>this.chain(new nC(e,this.commandOptions));zpopmin=(...e)=>this.chain(new nk(e,this.commandOptions));zrange=(...e)=>this.chain(new nI(e,this.commandOptions));zrank=(e,t)=>this.chain(new nN([e,t],this.commandOptions));zrem=(e,...t)=>this.chain(new n_([e,...t],this.commandOptions));zremrangebylex=(...e)=>this.chain(new nP(e,this.commandOptions));zremrangebyrank=(...e)=>this.chain(new nM(e,this.commandOptions));zremrangebyscore=(...e)=>this.chain(new nL(e,this.commandOptions));zrevrank=(e,t)=>this.chain(new nD([e,t],this.commandOptions));zscan=(...e)=>this.chain(new nU(e,this.commandOptions));zscore=(e,t)=>this.chain(new nj([e,t],this.commandOptions));zunionstore=(...e)=>this.chain(new nB(e,this.commandOptions));zunion=(...e)=>this.chain(new nG(e,this.commandOptions));get json(){return{arrappend:(...e)=>this.chain(new tV(e,this.commandOptions)),arrindex:(...e)=>this.chain(new tJ(e,this.commandOptions)),arrinsert:(...e)=>this.chain(new tX(e,this.commandOptions)),arrlen:(...e)=>this.chain(new tZ(e,this.commandOptions)),arrpop:(...e)=>this.chain(new tQ(e,this.commandOptions)),arrtrim:(...e)=>this.chain(new t0(e,this.commandOptions)),clear:(...e)=>this.chain(new t1(e,this.commandOptions)),del:(...e)=>this.chain(new t2(e,this.commandOptions)),forget:(...e)=>this.chain(new t5(e,this.commandOptions)),get:(...e)=>this.chain(new t3(e,this.commandOptions)),merge:(...e)=>this.chain(new t6(e,this.commandOptions)),mget:(...e)=>this.chain(new t4(e,this.commandOptions)),mset:(...e)=>this.chain(new t8(e,this.commandOptions)),numincrby:(...e)=>this.chain(new t7(e,this.commandOptions)),nummultby:(...e)=>this.chain(new t9(e,this.commandOptions)),objkeys:(...e)=>this.chain(new se(e,this.commandOptions)),objlen:(...e)=>this.chain(new st(e,this.commandOptions)),resp:(...e)=>this.chain(new ss(e,this.commandOptions)),set:(...e)=>this.chain(new sn(e,this.commandOptions)),strappend:(...e)=>this.chain(new si(e,this.commandOptions)),strlen:(...e)=>this.chain(new sr(e,this.commandOptions)),toggle:(...e)=>this.chain(new so(e,this.commandOptions)),type:(...e)=>this.chain(new sa(e,this.commandOptions))}}get functions(){return{load:(...e)=>this.chain(new ta(e,this.commandOptions)),list:(...e)=>this.chain(new tr(e,this.commandOptions)),delete:(...e)=>this.chain(new tn(e,this.commandOptions)),flush:()=>this.chain(new ti(this.commandOptions)),stats:()=>this.chain(new tc(this.commandOptions)),call:(...e)=>this.chain(new e9(e,this.commandOptions)),callRo:(...e)=>this.chain(new te(e,this.commandOptions))}}},nK=new Set(["scan","keys","flushdb","flushall","dbsize","hscan","hgetall","hkeys","lrange","sscan","smembers","xrange","xrevrange","zscan","zrange","exec"]),nH=class{pipelinePromises=new WeakMap;activePipeline=null;indexInCurrentPipeline=0;redis;pipeline;pipelineCounter=0;constructor(e){this.redis=e,this.pipeline=e.pipeline()}async withAutoPipeline(e){let t=this.activePipeline??this.redis.pipeline();this.activePipeline||(this.activePipeline=t,this.indexInCurrentPipeline=0);let s=this.indexInCurrentPipeline++;e(t);let n=this.deferExecution().then(()=>{if(!this.pipelinePromises.has(t)){let e=t.exec({keepErrors:!0});this.pipelineCounter+=1,this.pipelinePromises.set(t,e),this.activePipeline=null}return this.pipelinePromises.get(t)}),i=(await n)[s];if(i.error)throw new eI(`Command failed: ${i.error}`);return i.result}async deferExecution(){await Promise.resolve(),await Promise.resolve()}},nW=class extends eq{constructor(e,t){super([],{...t,headers:{Accept:"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"},path:["psubscribe",...e],streamOptions:{isStreaming:!0,onMessage:t?.streamOptions?.onMessage,signal:t?.streamOptions?.signal}})}},nY=class extends EventTarget{subscriptions;client;listeners;opts;constructor(e,t,s=!1,n){for(const i of(super(),this.client=e,this.subscriptions=new Map,this.listeners=new Map,this.opts=n,t))s?this.subscribeToPattern(i):this.subscribeToChannel(i)}subscribeToChannel(e){let t=new AbortController,s=new n$([e],{streamOptions:{signal:t.signal,onMessage:e=>this.handleMessage(e,!1)}});s.exec(this.client).catch(e=>{"AbortError"!==e.name&&this.dispatchToListeners("error",e)}),this.subscriptions.set(e,{command:s,controller:t,isPattern:!1})}subscribeToPattern(e){let t=new AbortController,s=new nW([e],{streamOptions:{signal:t.signal,onMessage:e=>this.handleMessage(e,!0)}});s.exec(this.client).catch(e=>{"AbortError"!==e.name&&this.dispatchToListeners("error",e)}),this.subscriptions.set(e,{command:s,controller:t,isPattern:!0})}handleMessage(e,t){let s=e.replace(/^data:\s*/,""),n=s.indexOf(","),i=s.indexOf(",",n+1),r=t?s.indexOf(",",i+1):-1;if(-1!==n&&-1!==i){let e=s.slice(0,n);if(t&&"pmessage"===e&&-1!==r){let e=s.slice(n+1,i),t=s.slice(i+1,r),o=s.slice(r+1);try{let s=this.opts?.automaticDeserialization===!1?o:JSON.parse(o);this.dispatchToListeners("pmessage",{pattern:e,channel:t,message:s}),this.dispatchToListeners(`pmessage:${e}`,{pattern:e,channel:t,message:s})}catch(e){this.dispatchToListeners("error",Error(`Failed to parse message: ${e}`))}}else{let t=s.slice(n+1,i),r=s.slice(i+1);try{if("subscribe"===e||"psubscribe"===e||"unsubscribe"===e||"punsubscribe"===e){let t=Number.parseInt(r);this.dispatchToListeners(e,t)}else{let s=this.opts?.automaticDeserialization===!1?r:nV(r);this.dispatchToListeners(e,{channel:t,message:s}),this.dispatchToListeners(`${e}:${t}`,{channel:t,message:s})}}catch(e){this.dispatchToListeners("error",Error(`Failed to parse message: ${e}`))}}}}dispatchToListeners(e,t){let s=this.listeners.get(e);if(s)for(let e of s)e(t)}on(e,t){this.listeners.has(e)||this.listeners.set(e,new Set),this.listeners.get(e)?.add(t)}removeAllListeners(){this.listeners.clear()}async unsubscribe(e){if(e)for(let t of e){let e=this.subscriptions.get(t);if(e){try{e.controller.abort()}catch{}this.subscriptions.delete(t)}}else{for(let e of this.subscriptions.values())try{e.controller.abort()}catch{}this.subscriptions.clear(),this.removeAllListeners()}}getSubscribedChannels(){return[...this.subscriptions.keys()]}},n$=class extends eq{constructor(e,t){super([],{...t,headers:{Accept:"text/event-stream","Cache-Control":"no-cache",Connection:"keep-alive"},path:["subscribe",...e],streamOptions:{isStreaming:!0,onMessage:t?.streamOptions?.onMessage,signal:t?.streamOptions?.signal}})}},nV=e=>{try{return JSON.parse(e)}catch{return e}},nJ=class{script;sha1;redis;constructor(e,t){this.redis=e,this.script=t,this.sha1="",this.init(t)}async init(e){this.sha1||(this.sha1=await this.digest(e))}async eval(e,t){return await this.init(this.script),await this.redis.eval(this.script,e,t)}async evalsha(e,t){return await this.init(this.script),await this.redis.evalsha(this.sha1,e,t)}async exec(e,t){return await this.init(this.script),await this.redis.evalsha(this.sha1,e,t).catch(async s=>{if(s instanceof Error&&s.message.toLowerCase().includes("noscript"))return await this.redis.eval(this.script,e,t);throw s})}async digest(e){let t=new TextEncoder().encode(e);return[...new Uint8Array(await eA.digest("SHA-1",t))].map(e=>e.toString(16).padStart(2,"0")).join("")}},nX=class{script;sha1;redis;constructor(e,t){this.redis=e,this.sha1="",this.script=t,this.init(t)}async init(e){this.sha1||(this.sha1=await this.digest(e))}async evalRo(e,t){return await this.init(this.script),await this.redis.evalRo(this.script,e,t)}async evalshaRo(e,t){return await this.init(this.script),await this.redis.evalshaRo(this.sha1,e,t)}async exec(e,t){return await this.init(this.script),await this.redis.evalshaRo(this.sha1,e,t).catch(async s=>{if(s instanceof Error&&s.message.toLowerCase().includes("noscript"))return await this.redis.evalRo(this.script,e,t);throw s})}async digest(e){let t=new TextEncoder().encode(e);return[...new Uint8Array(await eA.digest("SHA-1",t))].map(e=>e.toString(16).padStart(2,"0")).join("")}},nZ=class{client;opts;enableTelemetry;enableAutoPipelining;constructor(e,t){this.client=e,this.opts=t,this.enableTelemetry=t?.enableTelemetry??!0,t?.readYourWrites===!1&&(this.client.readYourWrites=!1),this.enableAutoPipelining=t?.enableAutoPipelining??!0}get readYourWritesSyncToken(){return this.client.upstashSyncToken}set readYourWritesSyncToken(e){this.client.upstashSyncToken=e}get json(){return{arrappend:(...e)=>new tV(e,this.opts).exec(this.client),arrindex:(...e)=>new tJ(e,this.opts).exec(this.client),arrinsert:(...e)=>new tX(e,this.opts).exec(this.client),arrlen:(...e)=>new tZ(e,this.opts).exec(this.client),arrpop:(...e)=>new tQ(e,this.opts).exec(this.client),arrtrim:(...e)=>new t0(e,this.opts).exec(this.client),clear:(...e)=>new t1(e,this.opts).exec(this.client),del:(...e)=>new t2(e,this.opts).exec(this.client),forget:(...e)=>new t5(e,this.opts).exec(this.client),get:(...e)=>new t3(e,this.opts).exec(this.client),merge:(...e)=>new t6(e,this.opts).exec(this.client),mget:(...e)=>new t4(e,this.opts).exec(this.client),mset:(...e)=>new t8(e,this.opts).exec(this.client),numincrby:(...e)=>new t7(e,this.opts).exec(this.client),nummultby:(...e)=>new t9(e,this.opts).exec(this.client),objkeys:(...e)=>new se(e,this.opts).exec(this.client),objlen:(...e)=>new st(e,this.opts).exec(this.client),resp:(...e)=>new ss(e,this.opts).exec(this.client),set:(...e)=>new sn(e,this.opts).exec(this.client),strappend:(...e)=>new si(e,this.opts).exec(this.client),strlen:(...e)=>new sr(e,this.opts).exec(this.client),toggle:(...e)=>new so(e,this.opts).exec(this.client),type:(...e)=>new sa(e,this.opts).exec(this.client)}}get functions(){return{load:(...e)=>new ta(e,this.opts).exec(this.client),list:(...e)=>new tr(e,this.opts).exec(this.client),delete:(...e)=>new tn(e,this.opts).exec(this.client),flush:()=>new ti(this.opts).exec(this.client),stats:()=>new tc(this.opts).exec(this.client),call:(...e)=>new e9(e,this.opts).exec(this.client),callRo:(...e)=>new te(e,this.opts).exec(this.client)}}use=e=>{let t=this.client.request.bind(this.client);this.client.request=s=>e(s,t)};addTelemetry=e=>{if(this.enableTelemetry)try{this.client.mergeTelemetry(e)}catch{}};createScript(e,t){return t?.readonly?new nX(this,e):new nJ(this,e)}pipeline=()=>new nF({client:this.client,commandOptions:this.opts,multiExec:!1});autoPipeline=()=>(function e(t,s="root"){return t.autoPipelineExecutor||(t.autoPipelineExecutor=new nH(t)),new Proxy(t,{get:(t,n)=>{if("pipelineCounter"===n)return t.autoPipelineExecutor.pipelineCounter;if("root"===s&&"json"===n)return e(t,"json");if("root"===s&&"functions"===n)return e(t,"functions");if("root"===s){let e=n in t&&!(n in t.autoPipelineExecutor.pipeline),s=nK.has(n);if(e||s)return t[n]}let i=t.autoPipelineExecutor.pipeline,r="json"===s?i.json[n]:"functions"===s?i.functions[n]:i[n];return"function"==typeof r?(...e)=>t.autoPipelineExecutor.withAutoPipeline(t=>{("json"===s?t.json[n]:"functions"===s?t.functions[n]:t[n])(...e)}):r}})})(this);multi=()=>new nF({client:this.client,commandOptions:this.opts,multiExec:!0});bitfield=(...e)=>new eW(e,this.client,this.opts);append=(...e)=>new eK(e,this.opts).exec(this.client);bitcount=(...e)=>new eH(e,this.opts).exec(this.client);bitop=(e,t,s,...n)=>new eY([e,t,s,...n],this.opts).exec(this.client);bitpos=(...e)=>new e$(e,this.opts).exec(this.client);copy=(...e)=>new eV(e,this.opts).exec(this.client);dbsize=()=>new eJ(this.opts).exec(this.client);decr=(...e)=>new eX(e,this.opts).exec(this.client);decrby=(...e)=>new eZ(e,this.opts).exec(this.client);del=(...e)=>new eQ(e,this.opts).exec(this.client);echo=(...e)=>new e0(e,this.opts).exec(this.client);evalRo=(...e)=>new e1(e,this.opts).exec(this.client);eval=(...e)=>new e2(e,this.opts).exec(this.client);evalshaRo=(...e)=>new e5(e,this.opts).exec(this.client);evalsha=(...e)=>new e3(e,this.opts).exec(this.client);exec=e=>new e6(e,this.opts).exec(this.client);exists=(...e)=>new e4(e,this.opts).exec(this.client);expire=(...e)=>new e8(e,this.opts).exec(this.client);expireat=(...e)=>new e7(e,this.opts).exec(this.client);flushall=e=>new tt(e,this.opts).exec(this.client);flushdb=(...e)=>new ts(e,this.opts).exec(this.client);geoadd=(...e)=>new th(e,this.opts).exec(this.client);geopos=(...e)=>new td(e,this.opts).exec(this.client);geodist=(...e)=>new tu(e,this.opts).exec(this.client);geohash=(...e)=>new tp(e,this.opts).exec(this.client);geosearch=(...e)=>new tm(e,this.opts).exec(this.client);geosearchstore=(...e)=>new tw(e,this.opts).exec(this.client);get=(...e)=>new tf(e,this.opts).exec(this.client);getbit=(...e)=>new tg(e,this.opts).exec(this.client);getdel=(...e)=>new tx(e,this.opts).exec(this.client);getex=(...e)=>new ty(e,this.opts).exec(this.client);getrange=(...e)=>new tb(e,this.opts).exec(this.client);getset=(e,t)=>new tE([e,t],this.opts).exec(this.client);hdel=(...e)=>new tO(e,this.opts).exec(this.client);hexists=(...e)=>new tR(e,this.opts).exec(this.client);hexpire=(...e)=>new tv(e,this.opts).exec(this.client);hexpireat=(...e)=>new tA(e,this.opts).exec(this.client);hexpiretime=(...e)=>new tT(e,this.opts).exec(this.client);httl=(...e)=>new tK(e,this.opts).exec(this.client);hpexpire=(...e)=>new tC(e,this.opts).exec(this.client);hpexpireat=(...e)=>new tk(e,this.opts).exec(this.client);hpexpiretime=(...e)=>new tI(e,this.opts).exec(this.client);hpttl=(...e)=>new tN(e,this.opts).exec(this.client);hpersist=(...e)=>new tS(e,this.opts).exec(this.client);hget=(...e)=>new t_(e,this.opts).exec(this.client);hgetall=(...e)=>new tP(e,this.opts).exec(this.client);hincrby=(...e)=>new tM(e,this.opts).exec(this.client);hincrbyfloat=(...e)=>new tL(e,this.opts).exec(this.client);hkeys=(...e)=>new tD(e,this.opts).exec(this.client);hlen=(...e)=>new tU(e,this.opts).exec(this.client);hmget=(...e)=>new tj(e,this.opts).exec(this.client);hmset=(e,t)=>new tG([e,t],this.opts).exec(this.client);hrandfield=(e,t,s)=>new eF([e,t,s],this.opts).exec(this.client);hscan=(...e)=>new tB(e,this.opts).exec(this.client);hset=(e,t)=>new tz([e,t],this.opts).exec(this.client);hsetnx=(e,t,s)=>new tq([e,t,s],this.opts).exec(this.client);hstrlen=(...e)=>new tF(e,this.opts).exec(this.client);hvals=(...e)=>new tH(e,this.opts).exec(this.client);incr=(...e)=>new tW(e,this.opts).exec(this.client);incrby=(...e)=>new tY(e,this.opts).exec(this.client);incrbyfloat=(...e)=>new t$(e,this.opts).exec(this.client);keys=(...e)=>new sc(e,this.opts).exec(this.client);lindex=(...e)=>new sl(e,this.opts).exec(this.client);linsert=(e,t,s,n)=>new sh([e,t,s,n],this.opts).exec(this.client);llen=(...e)=>new su(e,this.opts).exec(this.client);lmove=(...e)=>new sp(e,this.opts).exec(this.client);lpop=(...e)=>new sm(e,this.opts).exec(this.client);lmpop=(...e)=>new sd(e,this.opts).exec(this.client);lpos=(...e)=>new sw(e,this.opts).exec(this.client);lpush=(e,...t)=>new sf([e,...t],this.opts).exec(this.client);lpushx=(e,...t)=>new sg([e,...t],this.opts).exec(this.client);lrange=(...e)=>new sx(e,this.opts).exec(this.client);lrem=(e,t,s)=>new sy([e,t,s],this.opts).exec(this.client);lset=(e,t,s)=>new sb([e,t,s],this.opts).exec(this.client);ltrim=(...e)=>new sE(e,this.opts).exec(this.client);mget=(...e)=>new sO(e,this.opts).exec(this.client);mset=e=>new sR([e],this.opts).exec(this.client);msetnx=e=>new sv([e],this.opts).exec(this.client);persist=(...e)=>new sA(e,this.opts).exec(this.client);pexpire=(...e)=>new sT(e,this.opts).exec(this.client);pexpireat=(...e)=>new sS(e,this.opts).exec(this.client);pfadd=(...e)=>new sC(e,this.opts).exec(this.client);pfcount=(...e)=>new sk(e,this.opts).exec(this.client);pfmerge=(...e)=>new sI(e,this.opts).exec(this.client);ping=e=>new sN(e,this.opts).exec(this.client);psetex=(e,t,s)=>new s_([e,t,s],this.opts).exec(this.client);psubscribe=e=>{let t=Array.isArray(e)?e:[e];return new nY(this.client,t,!0,this.opts)};pttl=(...e)=>new sP(e,this.opts).exec(this.client);publish=(...e)=>new sM(e,this.opts).exec(this.client);randomkey=()=>new sL().exec(this.client);rename=(...e)=>new sD(e,this.opts).exec(this.client);renamenx=(...e)=>new sU(e,this.opts).exec(this.client);rpop=(...e)=>new sj(e,this.opts).exec(this.client);rpush=(e,...t)=>new sG([e,...t],this.opts).exec(this.client);rpushx=(e,...t)=>new sB([e,...t],this.opts).exec(this.client);sadd=(e,t,...s)=>new sz([e,t,...s],this.opts).exec(this.client);scan(e,t){return new sq([e,t],this.opts).exec(this.client)}scard=(...e)=>new sF(e,this.opts).exec(this.client);scriptExists=(...e)=>new sK(e,this.opts).exec(this.client);scriptFlush=(...e)=>new sH(e,this.opts).exec(this.client);scriptLoad=(...e)=>new sW(e,this.opts).exec(this.client);sdiff=(...e)=>new sY(e,this.opts).exec(this.client);sdiffstore=(...e)=>new s$(e,this.opts).exec(this.client);set=(e,t,s)=>new sV([e,t,s],this.opts).exec(this.client);setbit=(...e)=>new sJ(e,this.opts).exec(this.client);setex=(e,t,s)=>new sX([e,t,s],this.opts).exec(this.client);setnx=(e,t)=>new sZ([e,t],this.opts).exec(this.client);setrange=(...e)=>new sQ(e,this.opts).exec(this.client);sinter=(...e)=>new s0(e,this.opts).exec(this.client);sinterstore=(...e)=>new s1(e,this.opts).exec(this.client);sismember=(e,t)=>new s2([e,t],this.opts).exec(this.client);smismember=(e,t)=>new s3([e,t],this.opts).exec(this.client);smembers=(...e)=>new s5(e,this.opts).exec(this.client);smove=(e,t,s)=>new s6([e,t,s],this.opts).exec(this.client);spop=(...e)=>new s4(e,this.opts).exec(this.client);srandmember=(...e)=>new s8(e,this.opts).exec(this.client);srem=(e,...t)=>new s7([e,...t],this.opts).exec(this.client);sscan=(...e)=>new s9(e,this.opts).exec(this.client);strlen=(...e)=>new ne(e,this.opts).exec(this.client);subscribe=e=>{let t=Array.isArray(e)?e:[e];return new nY(this.client,t,!1,this.opts)};sunion=(...e)=>new nt(e,this.opts).exec(this.client);sunionstore=(...e)=>new ns(e,this.opts).exec(this.client);time=()=>new nn().exec(this.client);touch=(...e)=>new ni(e,this.opts).exec(this.client);ttl=(...e)=>new nr(e,this.opts).exec(this.client);type=(...e)=>new no(e,this.opts).exec(this.client);unlink=(...e)=>new na(e,this.opts).exec(this.client);xadd=(...e)=>new nl(e,this.opts).exec(this.client);xack=(...e)=>new nc(e,this.opts).exec(this.client);xdel=(...e)=>new np(e,this.opts).exec(this.client);xgroup=(...e)=>new nd(e,this.opts).exec(this.client);xread=(...e)=>new nx(e,this.opts).exec(this.client);xreadgroup=(...e)=>new ny(e,this.opts).exec(this.client);xinfo=(...e)=>new nm(e,this.opts).exec(this.client);xlen=(...e)=>new nw(e,this.opts).exec(this.client);xpending=(...e)=>new nf(e,this.opts).exec(this.client);xclaim=(...e)=>new nu(e,this.opts).exec(this.client);xautoclaim=(...e)=>new nh(e,this.opts).exec(this.client);xtrim=(...e)=>new nE(e,this.opts).exec(this.client);xrange=(...e)=>new ng(e,this.opts).exec(this.client);xrevrange=(...e)=>new nb(e,this.opts).exec(this.client);zadd=(...e)=>("score"in e[1],new nO([e[0],e[1],...e.slice(2)],this.opts).exec(this.client));zcard=(...e)=>new nR(e,this.opts).exec(this.client);zcount=(...e)=>new nv(e,this.opts).exec(this.client);zdiffstore=(...e)=>new nz(e,this.opts).exec(this.client);zincrby=(e,t,s)=>new nA([e,t,s],this.opts).exec(this.client);zinterstore=(...e)=>new nT(e,this.opts).exec(this.client);zlexcount=(...e)=>new nS(e,this.opts).exec(this.client);zmscore=(...e)=>new nq(e,this.opts).exec(this.client);zpopmax=(...e)=>new nC(e,this.opts).exec(this.client);zpopmin=(...e)=>new nk(e,this.opts).exec(this.client);zrange=(...e)=>new nI(e,this.opts).exec(this.client);zrank=(e,t)=>new nN([e,t],this.opts).exec(this.client);zrem=(e,...t)=>new n_([e,...t],this.opts).exec(this.client);zremrangebylex=(...e)=>new nP(e,this.opts).exec(this.client);zremrangebyrank=(...e)=>new nM(e,this.opts).exec(this.client);zremrangebyscore=(...e)=>new nL(e,this.opts).exec(this.client);zrevrank=(e,t)=>new nD([e,t],this.opts).exec(this.client);zscan=(...e)=>new nU(e,this.opts).exec(this.client);zscore=(e,t)=>new nj([e,t],this.opts).exec(this.client);zunion=(...e)=>new nG(e,this.opts).exec(this.client);zunionstore=(...e)=>new nB(e,this.opts).exec(this.client)};"undefined"==typeof atob&&(e.g.atob=e=>Buffer.from(e,"base64").toString("utf8"));var nQ=class e extends nZ{constructor(e){if("request"in e)return void super(e);e.url?(e.url.startsWith(" ")||e.url.endsWith(" ")||/\r|\n/.test(e.url))&&console.warn("[Upstash Redis] The redis url contains whitespace or newline, which can cause errors!"):console.warn("[Upstash Redis] The 'url' property is missing or undefined in your Redis config."),e.token?(e.token.startsWith(" ")||e.token.endsWith(" ")||/\r|\n/.test(e.token))&&console.warn("[Upstash Redis] The redis token contains whitespace or newline, which can cause errors!"):console.warn("[Upstash Redis] The 'token' property is missing or undefined in your Redis config.");const t=new eU({baseUrl:e.url,retry:e.retry,headers:{authorization:`Bearer ${e.token}`},agent:e.agent,responseEncoding:e.responseEncoding,cache:e.cache??"no-store",signal:e.signal,keepAlive:e.keepAlive,readYourWrites:e.readYourWrites}),s="object"==typeof process&&process&&"object"==typeof process.env&&process.env?process.env:{};super(t,{automaticDeserialization:e.automaticDeserialization,enableTelemetry:e.enableTelemetry??!s.UPSTASH_DISABLE_TELEMETRY,latencyLogging:e.latencyLogging,enableAutoPipelining:e.enableAutoPipelining});const n="object"==typeof process&&process?process.version:void 0;if(this.addTelemetry({runtime:"string"==typeof EdgeRuntime?"edge-light":n?`node@${n}`:"unknown",platform:s.UPSTASH_CONSOLE?"console":s.VERCEL?"vercel":s.AWS_REGION?"aws":"unknown",sdk:"@upstash/redis@v1.36.0"}),this.enableAutoPipelining)return this.autoPipeline()}static fromEnv(t){if("object"!=typeof process||!process||"object"!=typeof process.env||!process.env)throw TypeError('[Upstash Redis] Unable to get environment variables, `process.env` is undefined. If you are deploying to cloudflare, please import from "@upstash/redis/cloudflare" instead');let s=process.env.UPSTASH_REDIS_REST_URL||process.env.KV_REST_API_URL;s||console.warn("[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_URL`");let n=process.env.UPSTASH_REDIS_REST_TOKEN||process.env.KV_REST_API_TOKEN;return n||console.warn("[Upstash Redis] Unable to find environment variable: `UPSTASH_REDIS_REST_TOKEN`"),new e({...t,url:s,token:n})}};let n0=new class{constructor(e){this.apiKey=e}getGenerativeModel(e,t){if(!e.model)throw new K("Must provide a model name. Example: genai.getGenerativeModel({ model: 'my-model-name' })");return new eO(this.apiKey,e,t)}getGenerativeModelFromCachedContent(e,t,s){if(!e.name)throw new Y("Cached content must contain a `name` field.");if(!e.model)throw new Y("Cached content must contain a `model` field.");for(let s of["model","systemInstruction"])if((null==t?void 0:t[s])&&e[s]&&(null==t?void 0:t[s])!==e[s]){if("model"===s&&(t.model.startsWith("models/")?t.model.replace("models/",""):t.model)===(e.model.startsWith("models/")?e.model.replace("models/",""):e.model))continue;throw new Y(`Different value for "${s}" specified in modelParams (${t[s]}) and cachedContent (${e[s]})`)}let n=Object.assign(Object.assign({},t),{model:e.model,tools:e.tools,toolConfig:e.toolConfig,systemInstruction:e.systemInstruction,cachedContent:e});return new eO(this.apiKey,n,s)}}(process.env.GOOGLE_GENAI_API_KEY||""),n1=new eR.Ratelimit({redis:nQ.fromEnv(),limiter:eR.Ratelimit.slidingWindow(10,"1 m"),analytics:!0}),n2=new Map;async function n5(t){try{let s=await e.A(20081),n=s.default||s;return await n(t).rotate().withMetadata({exif:{},icc:void 0}).jpeg({quality:95}).toBuffer()}catch(e){return console.error("Metadata stripping failed:",e),t}}async function n3(e){try{let t,s;if(!process.env.GOOGLE_GENAI_API_KEY)return console.error("GOOGLE_GENAI_API_KEY is missing in environment variables"),q.NextResponse.json({error:"AI features are currently unavailable. Please configure GOOGLE_GENAI_API_KEY."},{status:503});let n=e.ip??e.headers.get("x-forwarded-for")??"127.0.0.1",{success:i,limit:r,reset:o,remaining:a}=await n1.limit(n);if(!i)return q.NextResponse.json({error:"Rate limit exceeded. Please try again later."},{status:429,headers:{"X-RateLimit-Limit":r.toString(),"X-RateLimit-Remaining":a.toString(),"X-RateLimit-Reset":o.toString()}});let{imageUrl:c,imageBase64:l,mimeType:h}=await e.json();if(!c&&!l)return q.NextResponse.json({error:"No image provided"},{status:400});let u=(l||c).substring(0,100),p=n2.get(u);if(p&&Date.now()-p.timestamp<36e5)return q.NextResponse.json({...p.result,cached:!0});let d=n0.getGenerativeModel({model:"gemini-1.5-flash"}),m=`
            Analyze this image for an apartment rental listing.
            1. Safety: Is there any inappropriate content (nudity, violence, drugs, or sensitive personal info)? (Status: SAFE or UNSAFE)
            2. Context: Does this look like it belongs in a property listing? (e.g., room, kitchen, bathroom, exterior building, furniture). (Status: RELEVANT or IRRELEVANT)
            3. Labels: Provide a short list of detected room types or objects.
            4. Reason: Briefly explain if it's UNSAFE or IRRELEVANT.

            Return JSON format only:
            {
                "safety": "SAFE" | "UNSAFE",
                "context": "RELEVANT" | "IRRELEVANT",
                "labels": ["kitchen", "white cabinets", ...],
                "reason": "..."
            }
        `;if(l){let e=Buffer.from(l,"base64");t=(await n5(e)).toString("base64"),s=h||"image/jpeg"}else{let e=await fetch(c),n=await e.arrayBuffer();t=(await n5(Buffer.from(n))).toString("base64"),s=h||e.headers.get("content-type")||"image/jpeg"}let w=(await d.generateContent([m,{inlineData:{data:t,mimeType:s}}])).response.text().match(/\{[\s\S]*\}/),f=w?JSON.parse(w[0]):{safety:"SAFE",context:"RELEVANT",labels:[],reason:""};if(n2.set(u,{result:f,timestamp:Date.now()}),n2.size>1e3){let e=Date.now();for(let[t,s]of n2.entries())e-s.timestamp>36e5&&n2.delete(t)}return q.NextResponse.json(f)}catch(e){if(console.error("Image moderation error:",e),e.message?.includes("quota"))return q.NextResponse.json({error:"API quota exceeded. Please try again later."},{status:503});if(e.message?.includes("invalid"))return q.NextResponse.json({error:"Invalid image format or data."},{status:400});return q.NextResponse.json({error:"Failed to moderate image",details:e.message,stack:e.stack},{status:500})}}e.s(["POST",()=>n3],37445);var n6=e.i(37445);let n4=new A.AppRouteRouteModule({definition:{kind:T.RouteKind.APP_ROUTE,page:"/api/moderate-image/route",pathname:"/api/moderate-image",filename:"route",bundlePath:""},distDir:".next",relativeProjectDir:"",resolvedPagePath:"[project]/src/app/api/moderate-image/route.ts",nextConfigOutput:"",userland:n6}),{workAsyncStorage:n8,workUnitAsyncStorage:n7,serverHooks:n9}=n4;function ie(){return(0,S.patchFetch)({workAsyncStorage:n8,workUnitAsyncStorage:n7})}async function it(e,t,s){n4.isDev&&(0,C.addRequestMeta)(e,"devRequestTimingInternalsEnd",process.hrtime.bigint());let n="/api/moderate-image/route";n=n.replace(/\/index$/,"")||"/";let i=await n4.prepare(e,t,{srcPage:n,multiZoneDraftMode:!1});if(!i)return t.statusCode=400,t.end("Bad Request"),null==s.waitUntil||s.waitUntil.call(s,Promise.resolve()),null;let{buildId:r,params:o,nextConfig:a,parsedUrl:c,isDraftMode:l,prerenderManifest:h,routerServerContext:u,isOnDemandRevalidate:p,revalidateOnlyGenerated:d,resolvedPathname:m,clientReferenceManifest:w,serverActionsManifest:f}=i,g=(0,N.normalizeAppPath)(n),x=!!(h.dynamicRoutes[g]||h.routes[m]),y=async()=>((null==u?void 0:u.render404)?await u.render404(e,t,c,!1):t.end("This page could not be found"),null);if(x&&!l){let e=!!h.routes[m],t=h.dynamicRoutes[g];if(t&&!1===t.fallback&&!e){if(a.experimental.adapterPath)return await y();throw new B.NoFallbackError}}let b=null;!x||n4.isDev||l||(b="/index"===(b=m)?"/":b);let E=!0===n4.isDev||!x,O=x&&!E;f&&w&&(0,I.setManifestsSingleton)({page:n,clientReferenceManifest:w,serverActionsManifest:f});let R=e.method||"GET",v=(0,k.getTracer)(),A=v.getActiveScopeSpan(),S={params:o,prerenderManifest:h,renderOpts:{experimental:{authInterrupts:!!a.experimental.authInterrupts},cacheComponents:!!a.cacheComponents,supportsDynamicResponse:E,incrementalCache:(0,C.getRequestMeta)(e,"incrementalCache"),cacheLifeProfiles:a.cacheLife,waitUntil:s.waitUntil,onClose:e=>{t.on("close",e)},onAfterTaskError:void 0,onInstrumentationRequestError:(t,s,n,i)=>n4.onRequestError(e,t,n,i,u)},sharedContext:{buildId:r}},q=new _.NodeNextRequest(e),F=new _.NodeNextResponse(t),K=P.NextRequestAdapter.fromNodeNextRequest(q,(0,P.signalFromNodeResponse)(t));try{let i=async e=>n4.handle(K,S).finally(()=>{if(!e)return;e.setAttributes({"http.status_code":t.statusCode,"next.rsc":!1});let s=v.getRootSpanAttributes();if(!s)return;if(s.get("next.span_type")!==M.BaseServerSpan.handleRequest)return void console.warn(`Unexpected root span type '${s.get("next.span_type")}'. Please report this Next.js issue https://github.com/vercel/next.js`);let i=s.get("next.route");if(i){let t=`${R} ${i}`;e.setAttributes({"next.route":i,"http.route":i,"next.span_name":t}),e.updateName(t)}else e.updateName(`${R} ${n}`)}),r=!!(0,C.getRequestMeta)(e,"minimalMode"),o=async o=>{var c,m;let w=async({previousCacheEntry:a})=>{try{if(!r&&p&&d&&!a)return t.statusCode=404,t.setHeader("x-nextjs-cache","REVALIDATED"),t.end("This page could not be found"),null;let n=await i(o);e.fetchMetrics=S.renderOpts.fetchMetrics;let c=S.renderOpts.pendingWaitUntil;c&&s.waitUntil&&(s.waitUntil(c),c=void 0);let l=S.renderOpts.collectedTags;if(!x)return await (0,D.sendResponse)(q,F,n,S.renderOpts.pendingWaitUntil),null;{let e=await n.blob(),t=(0,U.toNodeOutgoingHttpHeaders)(n.headers);l&&(t[G.NEXT_CACHE_TAGS_HEADER]=l),!t["content-type"]&&e.type&&(t["content-type"]=e.type);let s=void 0!==S.renderOpts.collectedRevalidate&&!(S.renderOpts.collectedRevalidate>=G.INFINITE_CACHE)&&S.renderOpts.collectedRevalidate,i=void 0===S.renderOpts.collectedExpire||S.renderOpts.collectedExpire>=G.INFINITE_CACHE?void 0:S.renderOpts.collectedExpire;return{value:{kind:z.CachedRouteKind.APP_ROUTE,status:n.status,body:Buffer.from(await e.arrayBuffer()),headers:t},cacheControl:{revalidate:s,expire:i}}}}catch(t){throw(null==a?void 0:a.isStale)&&await n4.onRequestError(e,t,{routerKind:"App Router",routePath:n,routeType:"route",revalidateReason:(0,L.getRevalidateReason)({isStaticGeneration:O,isOnDemandRevalidate:p})},!1,u),t}},f=await n4.handleResponse({req:e,nextConfig:a,cacheKey:b,routeKind:T.RouteKind.APP_ROUTE,isFallback:!1,prerenderManifest:h,isRoutePPREnabled:!1,isOnDemandRevalidate:p,revalidateOnlyGenerated:d,responseGenerator:w,waitUntil:s.waitUntil,isMinimalMode:r});if(!x)return null;if((null==f||null==(c=f.value)?void 0:c.kind)!==z.CachedRouteKind.APP_ROUTE)throw Object.defineProperty(Error(`Invariant: app-route received invalid cache entry ${null==f||null==(m=f.value)?void 0:m.kind}`),"__NEXT_ERROR_CODE",{value:"E701",enumerable:!1,configurable:!0});r||t.setHeader("x-nextjs-cache",p?"REVALIDATED":f.isMiss?"MISS":f.isStale?"STALE":"HIT"),l&&t.setHeader("Cache-Control","private, no-cache, no-store, max-age=0, must-revalidate");let g=(0,U.fromNodeOutgoingHttpHeaders)(f.value.headers);return r&&x||g.delete(G.NEXT_CACHE_TAGS_HEADER),!f.cacheControl||t.getHeader("Cache-Control")||g.get("Cache-Control")||g.set("Cache-Control",(0,j.getCacheControlHeader)(f.cacheControl)),await (0,D.sendResponse)(q,F,new Response(f.value.body,{headers:g,status:f.value.status||200})),null};A?await o(A):await v.withPropagatedContext(e.headers,()=>v.trace(M.BaseServerSpan.handleRequest,{spanName:`${R} ${n}`,kind:k.SpanKind.SERVER,attributes:{"http.method":R,"http.target":e.url}},o))}catch(t){if(t instanceof B.NoFallbackError||await n4.onRequestError(e,t,{routerKind:"App Router",routePath:g,routeType:"route",revalidateReason:(0,L.getRevalidateReason)({isStaticGeneration:O,isOnDemandRevalidate:p})},!1,u),x)throw t;return await (0,D.sendResponse)(q,F,new Response(null,{status:500})),null}}e.s(["handler",()=>it,"patchFetch",()=>ie,"routeModule",()=>n4,"serverHooks",()=>n9,"workAsyncStorage",()=>n8,"workUnitAsyncStorage",()=>n7],36751)}];

//# sourceMappingURL=%5Broot-of-the-server%5D__0da31cbb._.js.map